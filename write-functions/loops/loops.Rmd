---
title: "Loops"
tutorial:
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(grader)

grade_learnr <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  strict_check <- function(x) x
  check_code <- eval(parse(text = check_code))
  list(message = check_code, correct = TRUE, location = "append")
}

tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Loops in R

### \t

Many Data Science tasks require you to do the same thing over and over again. This is boring, drugerous work---but not for your computer! Computers are excellent at repetitive tasks.

But how do you ask your computer to repeat a task? 

* The purrr package provides one way. I recommend that you check out the Iteration primer to learn how to use purrr and its map functions.

* This tutorial will show you another way. You will learn how to repeat tasks with R's loop functions. Why learn about loops now? Because you know enough about R to understand loops, and loops will expand what you can do with your functions.

### Did you know?

Before we go on, you should know that some languages, like C, C++ and python, use loops as an _all purpose_ programming tool. This approach will not work well in R.

R's loops are the right tool for a very specific job, but they lose out to other methods for most jobs. This is due to R's user-oriented design: most R functions implement their own pre-optimized loops behind the scenes in a lower level language. These built-in loops are much faster than any loop you could write at the command line. 

But don't let this drive you loopy! You'll learn all you need to know about loops in R if you read through to the end of _Recursion and Vectorization_ before you leave this tutorial.

### loops

R contains three types of loops

1. `repeat`
1. `while` 
1. `for`

The simplest of these are `repeat` loops.

### repeat 

`repeat` repeats an expression over and over again. To use `repeat`, type `repeat` without trailing parentheses. Then use braces to enclose one or more lines of code, e.g.

```{r eval = FALSE}
repeat {
  print("Hello")
}
```

`repeat` will execute all of the code between the braces. Then it will execute it again. And again. And again...

### \t

```{r repeat-quiz, echo = FALSE}
question("When will `repeat` stop executing the code?",
         answer("After 10 times.", message = "Repeat will repeat your code until the end of time. This isn't particularly useful, so you will almost always use repeat with..."),
         answer("Never, unless you or your computer intervene.", correct = TRUE, 
         message = "Repeat will repeat your code until the end of time. This isn't particularly useful, so you will almost always use repeat with..."))
```

### break

When an R loop encounters the `break` command in a loop, it exits the loop. This provides a handy way to schedule the end of a `repeat` loop.

* How many times will R repeat the code in the loop below? Make a prediction then Click Submit Answer to see if you are right.

```{r repeat, exercise = TRUE}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
```

```{r repeat-solution}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
```

```{r repeat-check}
strict_check("R repeats the print statement five times and then exits the loop. Notice how we created an n variable to use with the loop. The loop reaches the end because we increment n by one each time we run the code. What would happen if you left out n <- n + 1? Don't try! The loop would print 1 for a very long time.")
```

### \t 

Here is a good question: 

What happens to the value of `n` when you run the loop? 

`n` is defined as `1` _outside_ of the loop. Is it still `1` outside of the loop when the loop is finished?

```{r results='hide'}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
n
```

* Click Submit Answer to find out.

```{r n, exercise = TRUE}
n
```

```{r n-solution}
n
```

```{r n-check}
strict_check("n = 5. Are you surprised? R's loops are not like functions, which safely execute code in a new environment. R's loops execute code in the environment that calls them, which means that loops will modify the objects in the environment. This is important to know. It can be very useful---but not if you forget that it happens.")
```

### count

One way to prevent loops from altering objects in your workspace is to put the loop into a function. For example, here is a function that counts from one to the number `x`. Do you see how it works?

```{r}
count <- function(x) {
  n <- 1
  repeat {
    print(n)
    if (n == x) break
    n <- n + 1
  }
}
```

* Can you write something similar? Write a function named `count_down` that counts from `x` to zero. Be sure to arrange for the loop to end! Then click Submit Answer.

```{r countdown, exercise = TRUE}
count_down <- function(x) {

  
  
  
  
  
}
```

```{r countdown-hint-1}
"Begin by setting n = x. In which direction should you increment n to get to zero?"
```

```{r countdown-hint-2}
"Increment n by subtracting one from it on each repetition. You will want to do this _after_ you print the value of n for that repetition."
```

```{r countdown-hint-3}
"Arrange to break the loop after you print n when n = 0."
```

```{r countdown-solution}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) break
    n <- n - 1
  }
}
```

```{r countdown-check}
strict_check("You know, this sounds a lot like a rocket launch...")
```

### return

`break` is not the only way to end a loop in R. 

If your loop is in a function, you can end the loop with a `return()` statement. R will stop executing the function (and therefore the loop) and return the value supplied by `return()`. 

* Alter your function below to end the loop with `return("Blast off!")`. You will no longer need the `break` command. Then click Submit Answer.

```{r blastoff, exercise = TRUE}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) break
    n <- n - 1
  }
}
```

```{r blastoff-hint}
"Replace `break` with something else."
```

```{r blastoff-solution}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) return("Blast off!")
    n <- n - 1
  }
}
```

```{r blastoff-check}
strict_check("Return is a useful way to return a message or value from a loop within a function.")
```

### \t

And for satisfaction's sake:

```{r echo = FALSE}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) return("Blast off!")
    n <- n - 1
  }
}
```

```{r}
count_down(10)
```

### \t

`repeat` captures the essence of loops in R, but it is the least commonly used type of loop. In the next section, you will learn how to refine `repeat` loops into two common types of loops: 

1. `while` loops, and
1. `for` loops

## while and for

### \t Case study - Prime numbers

In mathematics, a _prime_ number is a number that can only be divided evenly by itself and the number one. In other words, if you try to divide a prime number by any number less than itself, you get a remainder (_to keep things simple, we will only consider positive numbers_). 

For example, five is a prime number because you get a remainder when you divide it by two, three, and four:

```{r results ='hold'}
5 / 5
5 / 4
5 / 3
5 / 2
5 / 1
```

Interestingly, it is hard to prove that a number is prime...

### \t

...unless you are a computer. Then you can divide the number by every number less than itself and show that the result has a remainder.

Do you see where this is going? 

Yes! You are going to write a function that checks if a number is prime. (Consider this a computer science right of passage).

###  %%

To do this, you'll need to use the modulo function, `a %% b`. Modulo is an arithmetic operator that returns the remainder of dividing `a` by `b`. For example, when you divide five by five, nothing is left over. When you divide five by four, one is left over. When you divide five by three, two is left over. And so on.

```{r results='hold'}
5 %% 5
5 %% 4
5 %% 3
5 %% 2
5 %% 1
```

Modulo doesn't return a decimal, it returns the number that remains once you subtract from `a` the largest multiple of `b` (i.e the number you would get for the remainder if you did long division).

### prime

The code below uses a `repeat` loop to provide the beginnings of a prime function.

1. Change `n` to begin at `2` instead of `1`
1. Add an `if` statement that checks whether `x %% n == 0` and returns `FALSE` if so.
1. Add a second `if` statement that ends the loop and returns `TRUE` if/when the loop gets to `n == x`.
1. Then Click Submit Answer

```{r prime-repeat, exercise = TRUE}
prime <- function(x) {
  n <- 1
  repeat {
    print(n)
    
    
    n <- n + 1
  }
}
```

```{r prime-repeat-solution}
prime <- function(x) {
  n <- 2
  repeat {
    print(n)
    if (x %% n == 0) return(FALSE)
    if (n == x) return(TRUE)
    n <- n + 1
  }
}
```

```{r prime-repeat-check}
strict_check("Your loop works because a non-prime number will trigger the first if statement and return FALSE before the loop progresses to n = x. On the other hand, a prime number will not trigger the first if statement. It may not be the fanciest way to test for a prime number, but it works.")
```

### \t

* Use `prime` to check whether or not 89 is a prime number. Click Submit Answer to run your code.

```{r make-prime-repeat}
prime <- function(x) {
  n <- 2
  repeat {
    print(n)
    if (x %% n == 0) return(FALSE)
    if (n == x) return(TRUE)
    n <- n + 1
  }
}
```

```{r eighty-nine, exercise = TRUE, exercise.setup = "make-prime-repeat"}

```

```{r eighty-nine-solution}
prime(89)
```

```{r eighty-nine-check}
strict_check("89 *is* prime. Now that you have a working prime function, let's modify it to use a more streamlined loop.")
```

### A common pattern

It is common for `repeat` loops to run until a logical condition is met. 

For example, `prime` runs until `n == x` (or until `x %% n == 0`, if that happens first):

```{r eval = FALSE}
prime <- function(x) {
  # n <- 2
  repeat {
    # print(n)
    # if (x %% n == 0) return(FALSE)
    if (n == x) return(TRUE)
    # n <- n + 1
  }
}
```

### while

This pattern is so common that it gets its own type of loop: the `while` loop.

`while` takes a logical test, like `if`, and a chunk of code, like `repeat`. It will repeat the code until the logical test returns `FALSE` (unless something in the code ends the loop first).

So for example, these two loops do the same thing:

```{r}

# repeat
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}

# while
n <- 1
while (n <= 5) {
  print(n)
  n <- n + 1
}
```

### \t

`while` loops can be easier to write than `repeat` loops; you do not need to insert your own `if` statement. 

`while` loops are also easier to read: `while` makes the code author's intentions obvious.

### \t

1. Rewrite the `prime` function to use a `while` loop instead of a `repeat` loop. The new loop should run while `n` is less than `x`. 
1. Arrange for `prime` to return `TRUE` in its last line, after the loop is run. Under which conditions, will `prime` return this `TRUE`?
1. Then click Submit Answer.

```{r prime-while, exercise = TRUE}
prime <- function(x) {
  n <- 2
  repeat {
    print(n)
    if (x %% n == 0) return(FALSE)
    if (n == x) return(TRUE)
    n <- n + 1
  }
}
```

```{r prime-while-hint}
"The new loop should run while n is less than x."
```

```{r prime-while-solution}
prime <- function(x) {
  n <- 2
  while (n < x) {
    print(n)
    if (x %% n == 0) return(FALSE)
    n <- n + 1
  }
  TRUE
}
```

```{r}
strict_check("`prime` will only return TRUE if the loop comes to a natural end. That will only happen if `x` is a prime number. You already have the concept of loops down. Now you're just mastering the forms!")
```

### Another pattern

Embedded in both your `while` loop and your `repeat` loop is another common pattern:

Many loops increment over a defined set of values.

In the first version of `prime`, the loop incremented over the values `2`, `3`, `4`,  ...`x` (to check whether any of the numbers would prematurely end the loop).

You can see this in the code below: the loop begins at n = 2, ends at n = x, and advances one integer at a time between 2 and x.

```{r eval = FALSE}
# prime <- function(x) {
  n <- 2
  # repeat {
    # print(n)
    # if (x %% n == 0) return(FALSE)
    if (n == x) return(TRUE)
    n <- n + 1
  # }
# }
```

### \t

The while loop increments over the same set of values, `2`, `3`, `4`,  ...`x`, for the same reasons.

```{r eval = FALSE}
# prime <- function(x) {
  n <- 2
  while (n < x) {
    # print(n)
    # if (x %% n == 0) return(FALSE)
    n <- n + 1
  # }
  # TRUE
# }
```

### for

This task is so common, that R contains a third type of loop for incrementing over a set of values: the _for_ loop.

```{r}
for (n in c(1, 2, 3, 4, 5)) {
  print(n)
}
```

### for syntax

The syntax of `for` is similar to `while`, but instead of taking a logical test, `for` takes a three part statement:

1. A name. The name does not need to appear in the code chunk that follows `for`, but it often does.
2. `in` (this never changes)
3. A vector of values to iterate over. `for` will assign a different value of the vector to the name for each run of the loop.

`for` automatically ends the loop once it has iterated over each value in the vector.

### \t

The `for` loop is very versatile. With `for`, you do not need to worry about how to increment over strange sets of values:

```{r}
for (i in c(1, 10, 200)) {
  print(i)
}
```

### \t

Nor do you need to stick to ordered sets, or even numbers:

```{r}
for (person in c("Betty", "Veronica", "Archie")) {
  greeting <- paste("Hello", person)
  print(greeting)
}
```

### for the win

I'd like you to replace the `while` loop in prime with a `for` loop. 

```{r eval = FALSE}
prime <- function(x) {
  n <- 2
  while (n < x) {
    print(n)
    if (x %% n == 0) return(FALSE)
    n <- n + 1
  }
  TRUE
}
```

To do that you will need to figure out how to create the set `2`, `3`, `4`,  ...`x`.

### \t seq_len

One possibility is to use `seq_len(x)`, which creates a sequence of integers from `1` to `x`.

```{r}
seq_len(10)
```

* Convert `prime` to use a for loop that iterates over `n in seq_len(x)`. Then click Submit Answer.

```{r for-1, exercise = TRUE}
prime <- function(x) {
  n <- 2
  while (n < x) {
    print(n)
    if (x %% n == 0) return(FALSE)
    n <- n + 1
  }
  TRUE
}
```

```{r for-1-hint}
"You no longer need to define n with an initial value, nor do you need to increment n."
```

```{r for-1-solution}
prime <- function(x) {
  for (n in seq_len(x)) {
    print(n)
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

```{r}
strict_check("You are so close, but this version of prime has a bug. Can you see what it is?")
```

### \t

You did great converting the `while` loop to a `for` loop, but there is one small problem: `seq_len(x)` creates the set `1`, `2`, `3`, `4`,  ...`x`, but we want the set `2`, `3`, `4`,  ...`x`. 

See the difference? We don't want that `1`. It undermines our entire code strategy (no number will be returned as prime).

### next

One way around the problem is to use `next`, which is the last code helper provided by R. 

When R encounters `next` in a loop, it will move on to the next iteration of the loop without executing the rest of the loop. Here, when n = 1, `next` causes R to move on to the next iteration of the loop (where n will equal 2).

```{r eval = FALSE}
prime <- function(x) {
  for (n in seq_len(x)) {
    if (n == 1) next
    print(n)
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

### Quiz

```{r eval = FALSE}
n <- 1
while (n < 2) {
  print(n)
  next
  n <- n + 1
}
```

```{r next-quiz, echo = FALSE}
question("Will this loop run forever?",
         answer("No"),
         answer("Yes", correct = TRUE, message = "n will never increment to two  because R will skip over the end of the loop each time it encounters next. Be thoughtful when you write loops."),
         allow_retry = TRUE)
```

### seq

Another way around our `for` problem is to use `seq`, which creates a sequence of integers between two numbers.

```{r}
seq(2, 10)
```

`seq`, `seq_len` and `seq_along` form a complete family of helper functions for creating sequences in R.

### \t

Refine your prime function one last time.

* Use `seq` to make `prime` work correctly. Then click Submit Answer.

```{r for-2, exercise = TRUE}
prime <- function(x) {
  for (n in seq_len(x)) {
    print(n)
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

```{r for-2-solution}
prime <- function(x) {
  for (n in seq(2, x)) {
    print(n)
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

```{r for-2-check}
strict_check("You've learned how to use all of R's loop constructors! To be a loop master, click on the continue to learn when to use loops in R and when not to.")
```


## Recursion and vectorization

```{r}
prime <- function(x, n = 2) {
  if (n == x) TRUE
  else if (x %% n == 0) return(FALSE)
  else prime(x, n = n + 1)
}
```

## Practice
