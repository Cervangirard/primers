---
title: "Loops"
tutorial:
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(grader)

grade_learnr <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  strict_check <- function(x) x
  check_code <- eval(parse(text = check_code))
  list(message = check_code, correct = TRUE, location = "append")
}

tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Loops in R

### \t

Many Data Science tasks require you to do the same thing over and over again. This is boring, drugerous work---but not for your computer! Computers are excellent at repetitive tasks.

But how do you ask your computer to repeat a task? 

* The purrr package provides one way. I recommend that you check out the Iteration primer to learn how to use purrr and its map functions.

* This tutorial will show you another way. You will learn how to repeat tasks with R's loop functions. Why learn about loops now? Because you know enough about R to understand loops, and loops will expand what you can do with your functions.

### Did you know?

Before we go on, you should know that some languages, like C, C++ and python, use loops as an _all purpose_ programming tool. This approach will not work well in R.

R's loops are the right tool for a very specific job, but they lose out to other methods for most jobs. This is due to R's user-oriented design: most R functions implement their own pre-optimized loops behind the scenes in a lower level language. These built-in loops are much faster than any loop you could write at the command line. 

But don't let this drive you loopy! You'll learn all you need to know about loops in R if you read through to the end of _Recursion and Vectorization_ before you leave this tutorial.

### loops

R contains three types of loops

1. `repeat`
1. `while` 
1. `for`

The simplest of these are `repeat` loops.

### repeat 

`repeat` repeats an expression over and over again. To use `repeat`, type `repeat` without trailing parentheses. Then use braces to enclose one or more lines of code, e.g.

```{r eval = FALSE}
repeat {
  print("Hello")
}
```

`repeat` will execute all of the code between the braces. Then it will execute it again. And again. And again...

### \t

```{r repeat-quiz, echo = FALSE}
question("When will `repeat` stop executing the code?",
         answer("After 10 times.", message = "Repeat will repeat your code until the end of time. This isn't particularly useful, so you will almost always use repeat with..."),
         answer("Never, unless you or your computer intervene.", correct = TRUE, 
         message = "Repeat will repeat your code until the end of time. This isn't particularly useful, so you will almost always use repeat with..."))
```

### break

When an R loop encounters the `break` command in a loop, it exits the loop. This provides a handy way to schedule the end of a `repeat` loop.

* How many times will R repeat the code in the loop below? Make a prediction then Click Submit Answer to see if you are right.

```{r repeat, exercise = TRUE}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
```

```{r repeat-solution}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
```

```{r repeat-check}
strict_check("R repeats the print statement five times and then exits the loop. Notice how we created an n variable to use with the loop. The loop reaches the end because we increment n by one each time we run the code. What would happen if you left out n <- n + 1? Don't try! The loop would print 1 for a very long time.")
```

### \t 

Here is a good question: 

What happens to the value of `n` when you run the loop? 

`n` is defined as `1` _outside_ of the loop. Is it still `1` outside of the loop when the loop is finished?

```{r results='hide'}
n <- 1
repeat {
  print(n)
  if (n == 5) break
  n <- n + 1
}
n
```

* Click Submit Answer to find out.

```{r n, exercise = TRUE}
n
```

```{r n-solution}
n
```

```{r n-check}
strict_check("n = 5. Are you surprised? R's loops are not like functions, which safely execute code in a new environment. R's loops execute code in the environment that calls them, which means that loops will modify the objects in the environment. This is important to know. It can be very useful---but not if you forget that it happens.")
```

### count

One way to prevent loops from altering objects in your workspace is to put the loop into a function. For example, here is a function that counts from one to the number `x`. Do you see how it works?

```{r}
count <- function(x) {
  n <- 1
  repeat {
    print(n)
    if (n == x) break
    n <- n + 1
  }
}
```

* Can you write something similar? Write a function named `count_down` that counts from `x` to zero. Be sure to arrange for the loop to end! Then click Submit Answer.

```{r countdown, exercise = TRUE}
count_down <- function(x) {

  
  
  
  
  
}
```

```{r countdown-hint-1}
"Begin by setting n = x. In which direction should you increment n to get to zero?"
```

```{r countdown-hint-2}
"Increment n by subtracting one from it on each repetition. You will want to do this _after_ you print the value of n for that repetition."
```

```{r countdown-hint-3}
"Arrange to break the loop after you print n when n = 0."
```

```{r countdown-solution}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) break
    n <- n - 1
  }
}
```

```{r countdown-check}
strict_check("You know, this sounds a lot like a rocket launch...")
```

### return

`break` is not the only way to end a loop in R. You can also end a loop with a `return()` statement. R will exit the loop and return the value supplied by `return()`. 

* Alter your function below to end the loop with `return("Blast off!")`. You will no longer need the `break` command. Then click Submit Answer.

```{r blastoff, exercise = TRUE}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) break
    n <- n - 1
  }
}
```

```{r blastoff-hint}
"Replace `break` with something else."
```

```{r blastoff-solution}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) return("Blast off!")
    n <- n - 1
  }
}
```

```{r blastoff-check}
strict_check("Return is a useful way to return a message or value from a loop.")
```

### \t

And for satisfaction's sake:

```{r echo = FALSE}
count_down <- function(x) {
  n <- x
  repeat {
    print(n)
    if (n == 0) return("Blast off!")
    n <- n - 1
  }
}
```

```{r}
count_down(10)
```

### \t

`repeat` captures the essence of loops in R, but it is the least commonly used type of loop. In the next section, you will learn how to refine `repeat` loops into two common types of loops: 

1. `while` loops, and
1. `for` loops

## while and for

### \t Case study - Prime numbers

In mathematics, a _prime_ number is a number that can only be divided evenly by itself and the number one. In other words, if you try to divide a prime number by any number less than itself, you get a remainder (_to keep things simple, we will only consider positive numbers_). 

For example, five is a prime number because you get a remainder when you divide it by two, three, and four:

```{r results ='hold'}
5 / 5
5 / 4
5 / 3
5 / 2
5 / 1
```

Interestingly, it is hard to prove that a number is prime...

### \t

...unless you are a computer. Then you can divide the number by every number less than itself and show that the result has a remainder.

Do you see where this is going? 

Yes! You are going to write a function that checks if a number is prime. (Consider this a computer science right of passage).

###  %%

To do this, you'll need to use the modulo function, `a %% b`. Modulo is an arithmetic operator that returns the remainder of dividing `a` by `b`. For example, when you divide five by five, nothing is left over. When you divide five by four, one is left over. When you divide five by three, two is left over. And so on.

```{r results='hold'}
5 %% 5
5 %% 4
5 %% 3
5 %% 2
5 %% 1
```

Modulo doesn't return a decimal, it returns the number that remains once you subtract from `a` the largest multiple of `b` (i.e the number you would get for the remainder if you did long division).

### \t

If `x`





```{r}
prime <- function(x) {
  n <- 2
  repeat {
    print(n)
    if (n == x) return(TRUE)
    if (x %% n == 0) return(FALSE)
    n <- n + 1
  }
}
```

### while

```{r}
prime <- function(x) {
  n <- 2
  while (n < x) {
    print(n)
    if (x %% n == 0) return(FALSE)
    n <- n + 1
  }
  TRUE
}
```

### for

```{r}
prime <- function(x) {
  for (n in seq_len(x)) {
    print(n)
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

### next

```{r}
prime <- function(x) {
  for (n in seq_len(x)) {
    print(n)
    if (n == 1) next
    if (x %% n == 0) return(FALSE)
  }
  TRUE
}
```

## Recursion and vectorization

```{r}
prime <- function(x, n = 2) {
  if (n == x) TRUE
  else if (x %% n == 0) return(FALSE)
  else prime(x, n = n + 1)
}
```

## Practice
