---
title: "Environments and Scoping"
tutorial:
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(pryr)
library(grader)

tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Environments

###  

Thanks to the previous tutorials, you can write and execute functions, but can you predict how a function will work? 

To do that precisely, you need to know how R will look up the values of objects that appear in the function.

### \t

Consider the code below, which defines and then calls the function `foo()`. With its last line, `foo()` returns the value of `z`, but what will the value be?

```{r eval = FALSE}
z <- 1

foo <- function(z = 2) {
  z <- 3
  z
}

foo(z = 4)
```

```{r q1, echo = FALSE}
question("What will the value of `z` be?",
         answer("`1`, because we define `z <- 1` before defining the function."),
         answer("`2`, because `2` is the default value of the `z` argument."),
         answer("`3`, because the function runs `z <- 3`", correct = TRUE, message = "R can look for the value of z in many places, so it is important to know where R will look and why."),
         answer("`4`, because we define `z = 4` when we call the function."),
         allow_retry = TRUE, 
         incorrect = "Not Quite.")
```

### Scoping rules and environments

This tutorial will teach you R's rules for looking up values. 

The rules that a language uses to look up values are known as _scoping rules_, and R's scoping rules are closely tied to a new type of R object: the environment. So let's start there.

***

Before we begin, let me assure you: this topic is worth studying, even though it is unusually technical. R becomes much more predictable when you know how R looks up objects and their values.

### Environments

An R _environment_ is a list of object names paired with the values contained in the objects. Each environment is linked to another environment, and together these links form a chain of environments.

Every object in R is saved somewhere in an environment. When R needs to look up the value of an object, R searches through the chain of environments until R finds the object and its value.

That's the big picture. Let's look at the details.

### globalenv()

* Click Submit Answer to run the code below.

```{r global, exercise = TRUE}
globalenv()
```

```{r global-solution}
globalenv()
```

```{r global-check}
strict_check("globalenv() is a function that returns an R environment. In fact, globalenv() returns a very specific R environment that is named the global environment. You'll learn more about the global environment in a minute, but first take a look at how R displays environments. Notice that R's display is not very informative: it shows you only the label of the environment.")
```

### The global environment 

The global environment plays a very important role in R, and the function `globalenv()` makes the global environment particularly easy to access.

The global environment acts like your personal workspace when you run R in an R console, like the RStudio IDE. The _global environment_ is the environment where R:

1. saves all of the objects that you create at the command line 
2. looks to find all of the objects that you call from the command line

Other R environments include: 

* package environments (which contain all of the objects loaded by a package) 
* the empty environment (an empty environment with an important role) 
* temporary environments (that R creates to do certain tasks, like execute the exercise chunks in this tutorial)

### \t

Today, things are a little different because you are running R through an online tutorial. R is saving the objects that I create while I write the tutorial to the global environment, but R will save the objects that you create in the exercise chunks to a different environment. That's just how tutorials work. Its not a big deal, but I want you to be aware of it.

Would you like to see what I've saved in the global environment?

### `ls.str()`

You can display the contents of an R environment with `ls.str()`. 

* To see what I've saved in the global environment, run `ls.str()` on the code below. Then click Submit Answer. 

```{r include = FALSE}
x <- 1
y <- 2
z <- 3
```

```{r ls.str, exercise = TRUE}
globalenv()
```

```{r ls.str-hint}
"Pass `globalenv()` to `ls.str()`."
```

```{r ls.str-solution}
ls.str(globalenv())
```

```{r ls.str-check}
strict_check("I've only saved three objects to the global environment: `x`, `y`, and `z`. How did I do that? By running `x <- 1`, `y <- 2`, and `z <- 3` at the command line. ls.str() provides a good depiction of the global environment, because ls.str() shows the contents of the environment. However, ls.str()'s depiction of the global environment is missing one thing.")
```

### Parent environments

In addition to name-value pairs, each environment contains a link to _another_ environment. This second environment is called the _parent environment_ of the first environment. 

The relationship between an environment and its parent is a special relationship that we will return to in a moment. But first:

* Call `parent.env()` on `globalenv()` to see which environment is the parent environment of the global environment. Then click Submit Answer.

```{r parent, exercise = TRUE}

```

```{r parent-solution}
parent.env(environment())
```

```{r parent-check}
strict_check("You can use `parent.env()` to find the parent of any environment in R, but notice that there is no way to find the children of an environment: each child knows who its parent is, but each parent does not know who its children are. Compare this to real life: you can know who you are pointing at, but you can't know who may be pointing at you. Now that you know how to inspect an environment, let's look at how R uses environments.")
```


### The active environment

At any moment in time, R is working closely with a single environment, which I will call the _active environment_. If you create a new object, R will store it in the active environment. If you call an object, R will look for its value in the active environment. 

Which environment is active will change from time to time depending on what R is doing. You can use the `environment()` function to return the current active environment. 

As you may have guessed, the global environment is the active environment when you run code from the command line of an R console, like the RStudio IDE; but it is not the active environment when you run code from a tutorial exercise chunk.

* Type `environment()` in the exercise chunk below to return the label of the environment that is active when R runs the exercise chunk. Then click Submit Answer.

```{r active, exercise = TRUE}

```

```{r active-hint}
"Run `environment()` with no arguments."
```

```{r active-solution}
environment()
```

```{r active-check}
strict_check("The label of this environment is a random string. R generated this environment for the sole purpose of running the exercise chunk. If you run the chunk again R will generate a new environment (with a new label) to use on the second run of the exercise chunk. What's one side effect of this? Objects that you create on the first run will not be available in the active environment on the second run.")
```

### \t

What does the active environment of an exercise chunk contain? 
* Use the code block below to find out, then click Submit Answer.

```{r als, exercise = TRUE}

```

```{r als-hint}
"Which function returns the active environment? Which function displays the contents of an environment?"
```

```{r als-solution}
ls.str(environment())
```

```{r als-check}
strict_check('There is nothing in the active environment; it is a "fresh" environment just for you.')
```

### \t

What is the parent of the active environment of the exercise chunk?

* Use the code block below to find out, then click Submit Answer.

```{r pls, exercise = TRUE}

```

```{r pls-hint}
"Which function returns the active environment? Which function displays the parent of an environment?"
```

```{r pls-solution}
parent.env(environment())
```

```{r pls-check}
strict_check("The parent of each exercise chunk is the global environment.")
```

### Summary

You've learned three things about environments:

1. Every object in R is stored in an environment
2. An environment is a list of name-value pairs that define the values of R objects
3. Each environment contains a link to a parent environment (with the exception of an environment known as the empty environment).

### Question

What does R do if you call an object that is not in the active environment? 

For example, `pi` is not in the active environment, but R can clearly find `pi`

```{r}
pi
```

Let's find out.

## Scoping Rules

### parenvs()

Environment parentage is sort of like human parentage: if every environment has a parent, then every environment should also have a grandparent, a great-grandparent and so on.

You can see an environment's parentage with the `parenvs()` function that comes in the `pryr` package. Give `parenvs()` the argument `all = TRUE`; this tells `parenvs()` to display the parent of each parent. `parenvs(all = TRUE)` will display the parent of each environment beginning with the current active environment.

* Use `parenvs()` to see the "parentage" of the current active environment. Then click Submit Answer.

```{r search, exercise = TRUE}
library(pryr)

```

```{r search-hint}
"Don't forget the argument all = TRUE."
```

```{r search-solution}
library(pryr)
parenvs(all = TRUE)
```

```{r search-check}
strict_check("The current active environment is at the top of this list. The empty environment is at the bottom. The empty environment is the only R environment that does not have a parent. It is also the great ancestor of every other R environment.")
```

### R's scoping rules

The chain of parent environments from the active environment to the empty environment creates a _search path_ that R uses to look for objects.

1. R first looks for objects in the current active environment.

2. If R cannot find an object in the active environment, R looks for the object in the parent of the active environment. R then looks in the parent of the parent, and so on until R finds the object or comes to the empty environment.

3. If R gets to the empty environment before it finds an object, R will return the familiar error message: `Error: object not found`.

These three rules are R's scoping rules.

### The search path

R's search path will vary based on which environment is active when you call `parenvs()` (or begin searching). 

The search path will also vary based on which packages you have loaded. The environments of loaded packages appear between the global environment and the empty environment in the reverse order of which the packages were loaded. 

### where()

You can check which environment an object is defined in with the `where()` function that also comes in the pryr package. To use `where()`, give `where()` the name of an object as a character string. `where()` will return the first environment on the search path that contains the name. 

* Use `where()` to locate the environment that contains the name `"pi"`. Click Submit Answer to give it a try.

```{r where, exercise = TRUE}

```

```{r where-hint}
"Be sure to surround pi with quotation marks."
```

```{r where-solution}
where("pi")
```

```{r where-check}
strict_check("pi comes in the base package, which is always loaded when you open R.")
```

### Masking

Suppose you save a new object named `pi` at the command line. R will store it in the active environment.

```{r eval = FALSE}
pi <- "apple"
```

What would happen if you now call `pi` from the command line?

* Run `pi` below to see which value R returns. Can you explain the result? Click Submit Answer when you are finished.

```{r pi-setup}
pi <- "apple"
```

```{r pi, exercise = TRUE}

```

```{r pi-solution}
pi
```

```{r pi-check}
strict_check('R returns the first version of pi that R finds in the search path, and then R stops searching. Here R finds pi = "apple" in the global environment (because I defined pi for you). The global environment comes before the base environment, so R does not discover that there is a second version of pi (pi = 3.14) in the base environment.')
```

### \t

This behavior is called masking. _Masking_ occurs whenever two objects with the same name exist in the search path. In this case, R will always use the object that apears first in the search path. 

### masking and packages

R will help you screen for one common source of masking: R will return an informative message if you load a package that contains objects that mask other objects. Here, R tells us that the `date()` function in the lubridate package masks the `date()` function in the base package.

```{r}
library(lubridate)
```

***

Note that R will not warn you if **you** create an object that masks another object, as we saw with `pi`. So be thoughtful with your object names.

### ::

You can get around package masking with the `::` syntax. To use `::`, write a package name followed by `::` and then an object name. R will look up the object in the package environment, circumventing the search path and any masking conflicts.

```{r eval = FALSE}
pi
```

```{r echo = FALSE}
"apple"
```

```{r}
base::pi
```

### Overwriting

Masking can be confusing if you do not realize that it is happening, but there is something even worse than masking.

Remember that `pi = "apple"` is stored in the global environment, which is the environment where R stores each of the objects that I define at the command line. Suppose `pi = "apple"`, is an important variable. What would happen if I then ran this code at the command line?

```{r}
pi <- "pumpkin"
```

R will overwrite `pi = "apple"` with `pi = "pumpkin"` in the global environment. `pi = "apple"` will be lost because I've replaced it in the only environment that contained it. 

```{r}
pi
```

### Summary

In this section, you learned R's scoping rules:

1. R first looks for objects in the current active environment.

2. If R cannot find an object in the active environment, R looks for the object in the parent of the active environment. R then looks in the parent of the parent, and so on until R finds the object or comes to the empty environment.

3. If R gets to the empty environment before it finds an object, R will return the familiar error message: `Error: object not found`.


### \t

You've also learned of two dangers that R's scoping rules allow:

1. Masking, which happens when you create an object that has the same name as an object further down the search path
2. Overwriting, which happens when you assign a new value to a name that already exists in the active environment

### \t 

R's environment system and scoping rules are fairly straight forward; but due to masking and overwriting, R must integrate functions into the system in a special way.

### Functions

Now that you understand 

* environments
* the search path, and 
* the potential danger of overwriting/masking objects,

you have everything you need to know to understand how R functions look up values and why.


## Function Rules

###  

Many functions create temporary objects to do their jobs. For example, `foo()` creates an object named `z`. 

```{r eval = FALSE}
foo <- function(z = 2) {
  z <- 3
  z
}
```

These objects pose a problem: if R executes the function in the active environment, the function will add an object named `z` to the environment. `z` may mask another object in the search path, or even worse, `z` may overwrite an object that already exists in the active environment.

### Calling and Execution Environments

R avoids this chaos by creating a new environment each time it runs a function. R makes the new environment the active environment, runs the code contained in the function, and then switches back to whichever environment was active when you called the function. 

I'll call the environment that is active when you call a function the _calling environment_.

I'll call the new environment that R makes to run the function, an _execution environment_, because R uses this environment to execute the function. 

Execution environments prevent functions from overwriting existing objects. R stores any objects created by the function in the new, out-of-the-way, execution environment. Since R returns to the calling environment after running the function, the execution environment will not appear on the search path. As a result, none of its objects will mask others.

### \t

With a little ingenuity, you can see an execution environment at work.

Take a look at the function below. When R runs `show_execution_env()`, R will

1. create a new  environment (an exectution environment)
2. make the execution environment the active environment
3. execute the code in `show_execution_env()`, which will call `environment()`, which will return the label of the execution environment (because at that moment the execution environment will be the active environment)
4. make the calling environment the active environment again

```{r eval = FALSE}
show_execution_env <- function() {
  environment()
}
```

###  

Click Run Code below a few times to see the results of `show_execution_env()`. 

```{r show-setup}
show_execution_env <- function() {
  environment()
}
```

```{r show, exercise = TRUE}
environment()        # the calling environment
show_execution_env() # the execution environment
environment()        # the calling environment, active again
```

Here are a few things to notice:

1. R runs the exercise chunk in a _new_ environment each time you click Run Code; this is how exercise chunks work in a tutorial. The first and third results show this environment, which becomes the calling environment for `show_execution_env()`.
2. R always runs the code body of `show_exectution_env()` in a new environment that is not the calling environment. The second result shows the label of this environment, which is the execution environment of `show_execution_env()`.
3. R always switches back to the calling environment after it runs the code body of `show_execution_env()`. So the first and third labels will always match.

See the pattern?

### Looking up function objects

Execution environments also affect how R will look up values while executing a function. 

As always, R will look for objects in the current active environment, which will be the execution environment while the function code runs. 

Do you remember where R will look next if it does not find an object in the active environment?

### \t

If you said the parent of the active environment you are correct! But what is the parent of an execution environment? Let's find out. 

### \t

First, you will need to know that every function in R knows where it was originally defined. For example, the `date()` function in the lubridate package was originally defined in... the lubridate package environment.

```{r}
environment(date)
```





Here is a function that I defined in the global setup chunk of this tutorial. (In other words, R ran this code when the tutorial first loaded; so `show_execution_par` was defined in a different environment than the active environment of the exercise chunk.)

```{r eval = FALSE}
show_execution_par <- function() {
  env <- environment()
  par <- parent.env(env)
  list(environment = env, parent = par)
}
```

`show_execution_par()` behaves similar to `show_execution_env()`. However, `show_execution_par()` returns a list that contains both the label of the execution environment that R uses to run `show_execution_par()` _and_ the label of the parent of the execution environment.

###  

* Run the code below several times. Then click Submit Answer. 
* What is the parent of the execution environment? 
* Does the parent ever change?

```{r show2, exercise = TRUE}
environment() # the active environment when you call show_execution_par
show_execution_par()
```

```{r show2-solution}
environment() # the active environment when you call show_execution_par
show_execution_par()
```

```{r show2-check}
strict_check("There are two things to notice here: 1) the parent of the execution environment never changes, even though the execution environments change: R creates a new execution environment each time R runs the function, and 2) the parent of the execution environment is NOT the environment that was active when R called show_execution_par().")
```

### Enclosing Environments

The parent of an execution environment will always be _the environment in which the function was originally defined_. This environment is known as the _enclosing environment_ of the function.

A function's enclosing environment never changes. Each time you call the function, R will generate a new execution environment, but each execution environment will use the same enclosing environment as its parent.

You can see a function's enclosing environment by running `environment()` on the function.

* Give it a try. What is the enclosing environment of `show_execution_par`? Click Submit Answer when you are finished.

```{r enclose, exercise = TRUE}

```

```{r enclose-hint}
"Pass show_execution_par as an object name to environment(); don't surround it in quotation marks or follow it with parentheses."
```

```{r enclose-solution}
environment(show_execution_par)
```

```{r enclose-check}
strict_check("This is the same environment that show_execution_par() returns as the parent environment each time you run show_execution_par().")
```

### Search paths

The enclosing environment plays an important role for a function. The enclosing environment determines the function's search path. (Why? Because R will look in the enclosing environment and then the parent of the enclosing environment and so on, if R does not find an object in the execution environment).

If a function was defined in the global environment (or whichever environment the function was called from) then the search path of the environment from which the function was called will align with the search path of the environment in which the function's code is run. **But usually these two search paths do not align.**

In other words, a function will usually not be able to find objects that are defined in your active environment.

###  

Once again, we can see this in action by crafting our ouwn function. I defined `show_path` in the global set up chunk of this tutorial, so `show_path`'s enclosing environment will not be the active environment of the exercise chunk below.

```{r eval = FALSE}
show_path <- function() {
  env <- environment()
  path <- parenvs(all = TRUE)
  list(environment = env, path = path)
}
```

* Run the code below and compare the two search paths.
* Where will the object `a` be defined? 
* Would R be able to find `a` when it runs the code inside `show_path`? Why or why not?
* Click Submit Answer when you are finished.

```{r path, exercise = TRUE}
a <- 1
environment() # The active environment
parenvs(all = TRUE) # the search path from the active environment
show_path() # the search path from the execution environment
```

```{r path-solution}
a <- 1
environment() # The active environment
parenvs(all = TRUE) # the search path from the active environment
show_path() # the search path from the execution environment
```

```{r path-check}
strict_check("The search path for show_path() bypasses the calling environment, which contains a. This raises an important question: how could you pass a to show_path() if show_path() needed to use a? Before we look at the answer, let's summarize R's function evaluation rules.")
```

### Summary

To evaluate a function, R:

1. Creates a new _execution environment_ to use as the active environment while R runs the code in the function's code body.
2. Uses the function's _enclosing environment_ as the parent of the execution environment. The enclosing environment is the environment in which the function was orginially defined. This environment determines the search path that R will use to look up objects while R runs the code in the function's body.
3. Makes the _calling environment_ active again when R has finished running the code in the function body. The calling environment is whichever environment was active when R called the function.

## Call Stack