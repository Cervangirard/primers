---
title: "Environments and Scoping"
tutorial:
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(pryr)
library(grader)
library(envtutorial)

tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Environments

###  

Thanks to the previous tutorials, you can write and execute functions, but can you predict how a function will work? 

To do that precisely, you need to know how R will look up the values of objects that appear in the function.

Consider the code below, which defines and then calls the function `foo()`. With its last line, `foo()` returns the value of `z`, but what will the value be?

```{r eval = FALSE}
z <- 1

foo <- function(z = 2) {
  z <- 3
  z
}

foo(z = 4)
```

### \t

```{r q1, echo = FALSE}
question("What will the value of `z` be?",
         answer("`1`, because we define `z <- 1` before defining the function."),
         answer("`2`, because `2` is the default value of the `z` argument."),
         answer("`3`, because the function runs `z <- 3`", correct = TRUE, message = "R can look for the value of z in many places, so it is important to know where R will look and why."),
         answer("`4`, because we define `z = 4` when we call the function."),
         allow_retry = TRUE, 
         incorrect = "Not Quite.")
```

### Scoping rules and environments

This tutorial will teach you R's rules for looking up values. 

The rules that a language uses to look up values are known as _scoping rules_, and R's scoping rules are closely tied to a new type of R object: the environment. So let's start there.

***

Before we begin, let me assure you: this topic is worth studying, even though it is unusually technical. R becomes much more predictable when you know how R looks up objects and their values.

### The big picture

An R _environment_ is a list of object names paired with the values contained in the objects. Each environment is linked to another environment, and together these links form a chain of environments.

Every object in R is saved somewhere in an environment. When R needs to look up the value of an object, R searches through the chain of environments until R finds the object and its value.

That's the big picture. Let's look at the details.

### globalenv()

`globalenv()` is a function that returns an R environment. In fact, `globalenv()` returns a very specific R environment named the _global environment_. You'll learn more about the global environment in a minute, but first take a look at how R displays environments. 

* Click Submit Answer to run the code below.

```{r global, exercise = TRUE}
globalenv()
```

```{r global-solution}
globalenv()
```

```{r global-check}
strict_check("Notice that R's display is not very informative: it shows you only the label of the environment.")
```

### The global environment 

The global environment plays a very important role in R, and the function `globalenv()` makes the global environment particularly easy to access.

The global environment acts like your personal workspace when you run R in an R console, like the RStudio IDE. The _global environment_ is the environment where R:

1. saves all of the objects that you create at the command line 
2. looks to find all of the objects that you call from the command line

Other R environments include: 

* package environments (which contain all of the objects loaded by a package) 
* the empty environment (an empty environment with an important role) 
* temporary environments (that R creates to do certain tasks, like execute the exercise chunks in this tutorial)

### \t

Today, things are a little weird because you are running R through an online tutorial. R is saving the objects that I create while I write the tutorial to the global environment, but R will save the objects that you create in the exercise chunks to a different environment. That's just how tutorials work. Its not a big deal, but I want you to be aware of it.

Would you like to see what I've saved in the global environment?

### `ls.str()`

You can display the contents of an R environment with `ls.str()`. 

* To see what I've saved in the global environment, run `ls.str()` on the code below. Then click Submit Answer. 

```{r include = FALSE}
x <- 1
y <- 2
z <- 3
```

```{r ls.str, exercise = TRUE}
globalenv()
```

```{r ls.str-hint}
"Pass `globalenv()` to `ls.str()`."
```

```{r ls.str-solution}
ls.str(globalenv())
```

```{r ls.str-check}
strict_check("I've only saved three objects to the global environment: `x`, `y`, and `z`. How did I do that? By running `x <- 1`, `y <- 2`, and `z <- 3` at the command line. ls.str() provides a good depiction of the global environment, because ls.str() shows the contents of the environment. However, ls.str()'s depiction of the global environment is missing one thing.")
```

### Parent environments

In addition to name-value pairs, each environment contains a link to _another_ environment. This second environment is called the _parent environment_ of the first environment. 

The relationship between an environment and its parent is a special relationship that we will return to in a moment. But first:

* Call `parent.env()` on `globalenv()` to see which environment is the parent environment of the global environment. Then click Submit Answer.

```{r parent, exercise = TRUE}

```

```{r parent-solution}
parent.env(globalenv())
```

```{r parent-check}
strict_check("You can use `parent.env()` to find the parent of any environment in R, but notice that there is no way to find the children of an environment: each child knows who its parent is, but each parent does not know who its children are. Compare this to real life: you can know who you are pointing at, but you can't know who may be pointing at you. (You can ignore the extra attributes that appear with this environment label). Now that you know how to inspect an environment, let's look at how R uses environments.")
```


### The active environment

At any moment in time, R is working closely with a single environment, which I will call the _active environment_. If you create a new object, R will store it in the active environment. If you call an object, R will look for its value in the active environment. 

Which environment is active will change from time to time depending on what R is doing. You can use the `environment()` function to return the current active environment. 

As you may have guessed, the global environment is the active environment when you run code from the command line of an R console, like the RStudio IDE; but it is not the active environment when you run code from a tutorial exercise chunk.

* Type `environment()` in the exercise chunk below to return the label of the environment that is active when R runs the exercise chunk. Then click Submit Answer.

```{r active, exercise = TRUE}

```

```{r active-hint}
"Run `environment()` with no arguments."
```

```{r active-solution}
environment()
```

```{r active-check}
strict_check("The label of this environment is a random string. R generated this environment for the sole purpose of running the exercise chunk. If you run the chunk again R will generate a new environment (with a new label) to use on the second run of the exercise chunk. What's one side effect of this? Objects that you create on the first run will not be available in the active environment on the second run.")
```

### \t

What is stored in the active environment of an exercise chunk? 

* Use the code block below to find out, then click Submit Answer.

```{r als, exercise = TRUE}

```

```{r als-hint}
"Which function returns the active environment? Which function displays the contents of an environment?"
```

```{r als-solution}
ls.str(environment())
```

```{r als-check}
strict_check('There is nothing in the active environment; it is a "fresh" environment just for you.')
```

### \t

What is the parent of the active environment of the exercise chunk?

* Use the code block below to find out, then click Submit Answer.

```{r pls, exercise = TRUE}

```

```{r pls-hint}
"Which function returns the active environment? Which function displays the parent of an environment?"
```

```{r pls-solution}
parent.env(environment())
```

```{r pls-check}
strict_check("The parent of each exercise chunk is the global environment.")
```

### Summary

You've learned three things about environments:

1. Every object in R is stored in an environment
2. An environment is a list of name-value pairs that define the values of R objects
3. Each environment contains a link to a parent environment (with the exception of an environment known as the empty environment).

### Question

What does R do if you call an object that is not in the active environment? 

For example, `pi` is not in the active environment, but R can clearly find `pi`

```{r}
pi
```

Let's find out. The answer has something to do with parentage.

## Scoping Rules

### parenvs()

Environment parentage is sort of like human parentage: if every environment has a parent, then every environment should also have a grandparent, a great-grandparent and so on.

You can see an environment's parentage with the `parenvs()` function that comes in the `pryr` package. Give `parenvs()` the argument `all = TRUE`; this tells `parenvs()` to display the parent of each parent. `parenvs(all = TRUE)` will display the parent of each environment beginning with the current active environment.

* Use `parenvs()` to see the "parentage" of the current active environment. Then click Submit Answer.

```{r search, exercise = TRUE}
library(pryr)

```

```{r search-hint}
"Don't forget the argument all = TRUE."
```

```{r search-solution}
library(pryr)
parenvs(all = TRUE)
```

```{r search-check}
strict_check("The current active environment is at the top of this list. The second line contains the global environment, which is the parent of the active environment. The third line contains the parent of the global environment, and so on. The empty environment is at the bottom. The empty environment is the only R environment that does not have a parent. It is also the great ancestor of every other R environment.")
```

### R's scoping rules

The chain of parent environments from the active environment to the empty environment creates a _search path_ that R uses to look for objects.

1. R first looks for objects in the current active environment.

2. If R cannot find an object in the active environment, R looks for the object in the parent of the active environment. R then looks in the parent of the parent, and so on until R finds the object or comes to the empty environment.

3. If R gets to the empty environment before it finds an object, R will return the familiar error message: `Error: object not found`.

These three rules are R's scoping rules.

### The search path

R's search path will vary based on which environment is active when you call `parenvs()` (or begin searching). 

The search path will also vary based on which packages you have loaded. The environments of loaded packages appear between the global environment and the empty environment in the reverse order of which the packages were loaded. 

### where()

You can check which environment an object is defined in with the `where()` function that also comes in the pryr package. To use `where()`, give `where()` the name of an object as a character string. `where()` will return the first environment on the search path that contains the name. 

* Use `where()` to locate the environment that contains the name `"pi"`. Click Submit Answer to give it a try.

```{r where, exercise = TRUE}

```

```{r where-hint}
"Be sure to surround pi with quotation marks."
```

```{r where-solution}
where("pi")
```

```{r where-check}
strict_check("pi comes in the base package, which is always loaded when you open R.")
```

### Masking

Suppose you save a new object named `pi` at the command line. R will store it in the active environment.

What would happen if you then called `pi` from the command line?

* Run the code below to see which value R returns. Can you explain the result? Click Submit Answer when you are finished.

```{r pi, exercise = TRUE}
pi <- "apple"
pi
```

```{r pi-solution}
pi
```

```{r pi-check}
strict_check('R returns the first version of pi that R finds in the search path, and then R stops searching. Here R finds pi = "apple" in the active environment (because you defined a new pi, which is saved in the active environment). The active environment comes before the base environment on the search path, so R does not discover that there is a second version of pi (pi = 3.14) in the base environment.')
```

### \t

This behavior is called masking. _Masking_ occurs whenever two objects with the same name exist in the search path. In this case, R will always use the object that apears first in the search path. 

### masking and packages

R will help you screen for one common source of masking: R will return an informative message if you load a package that contains objects that mask other objects. Here, R tells us that the `date()` function in the lubridate package masks the `date()` function in the base package.

```{r}
library(lubridate)
```

***

Note that R will not warn you if **you** create an object that masks another object, as we saw with `pi`. So be thoughtful with your object names.

### ::

You can get around package masking with the `::` syntax. To use `::`, write a package name followed by `::` and then an object name. R will look up the object in the package environment, circumventing the search path and any masking conflicts.

```{r eval = FALSE}
pi
```

```{r echo = FALSE}
"apple"
```

```{r}
base::pi
```

### Overwriting

Masking can be confusing if you do not realize that it is happening, but there is something even worse than masking.

Suppose that `pi = "apple"` is stored in the active environment. (In fact, I've stored it in the active environment for you. You can click Run Code to check if you like.)

Pretend `pi = "apple"`, is an important variable. What would happen if you then ran this code at the command line?

* Make a prediction. Then click Submit Answer to find out.

```{r pumpkin-setup}
pi <- "apple"
```

```{r pumpkin, exercise = TRUE}
pi <- "pumpkin"
pi
```

```{r pumpkin-solution}
pi <- "pumpkin"
pi
```

```{r pumpkin-check}
strict_check('R will overwrite `pi = "apple"` with `pi = "pumpkin"` in the active environment. `pi = "apple"` will be lost because you have replaced it in the only environment that contained it. ')
```

### Summary

In this section, you learned R's scoping rules:

1. R first looks for objects in the current active environment.

2. If R cannot find an object in the active environment, R looks for the object in the parent of the active environment. R then looks in the parent of the parent, and so on until R finds the object or comes to the empty environment.

3. If R gets to the empty environment before it finds an object, R will return the familiar error message: `Error: object not found`.


### \t

You've also learned of two dangers that R's scoping rules allow:

1. Masking, which happens when you create an object that has the same name as an object further down the search path
2. Overwriting, which happens when you assign a new value to a name that already exists in the active environment

### \t 

R's environment system and scoping rules are fairly straight forward; but due to masking and overwriting, R must do something special when it runs functions.


## Function Rules

###  

Many functions create temporary objects to do their jobs. For example, `foo()` creates an object named `z`. 

```{r eval = FALSE}
foo <- function(z = 2) {
  z <- 3
  z
}
```

What if there is already an object named `z` in the active environment when you call `foo()`? Suppose there is an object named `z` that contains the important string, `"password123"`.

```{r fq1, echo = FALSE}
question("If R runs `foo()` in the active environment, which of the following would happen?",
         answer("R will overwrite password123 with 3.", correct = TRUE, message = "z poses a problem: if R executes foo() in the active environment, foo() will add an object named z to the environment, which would overwrite an object that already exists in the active environment."),
         answer("R will not run the line of code z <- 3; R will use the prexisting value of z."),
         answer("An error"),
         answer("R will save the new version of z as z.2"),
         allow_retry = TRUE)
```

### Execution environments

R avoids this chaos by creating a new environment to run the code body of `foo()` in. In fact, each time you call a function in R:

1. R creates a new environment
2. R makes the new environment the active environment
3. R runs the code body of the function in the new, active environment

As a result, any objects created by the function are stored in a safe environment, where they will not overwrite previously existing objects.

I'll call the environment that is active when you call a function the _calling environment_.

I'll call the new environment that R makes to run the function, an _execution environment_, because R uses this environment to execute the function. 

### How long are execution environments the active environment?

To summarize, when you run `foo()`, R creates an execution environment to run `z <- 3` and `z` in. When `foo()` has finished running, this execution environment contains a single object, `z = 3` and the calling environment retains its object, `z = password123`.

Suppose this is all R does, and the execution environment is now the current active environment.

```{r fq2, echo = FALSE}
question("What would happen if you now run `z` to retrieve your password?",
         answer("R will return 3, because the new value of z masks the old value.", correct = TRUE, message = "R will return the first value of z that R finds on the search path. Since the search path always begins in the active environment, R will return z = 3, which is stored in the execution environment (which we have supposed is still active)."),
         answer("R will return password123."),
         answer("R will return an error message"),
         allow_retry = TRUE)
```

###

As you can see, creating an execution environment does not completely solve the `z` problem. The execution environment prevents `z <- 3` from overwriting `z = "password123"` in the calling environment, but `z <- 3` would still mask `z = "password123"` if the execution environment remains active.

R solves that problem with a simple action: R switches the active environment back to the calling environment each time R finishes running a function. If the function returns a result, this result will be passed back to the calling environment (where you can save it with `<-`).

As a result, execution environments do not remain on the search path. Any objects that a function creates are stored safely out of the way: they cannot mask or overwrite existing objects. They also cannot be easily retrieved, so be sure to have your function return anything of importance in its result.

### show_env()

Let's take a peek at an execution environment in action. `show_env()` is a function in the `envtutorial` package, which is a package I made specifically for this tutorial.

The definition of `show_env()` looks like this: 

```{r}
show_env <- function() {
  call <- parent.frame()
  exec <- environment()
  list(calling = call, execution = exec)
}
```

When you run `show_env()`, R will create an execution environment to run the contents of `show_env()` in. The first line of `show_env()` will capture the name of the environment from which you called `show_env()` (pro tip: thats what `parent.frame()` does). This will be the calling environment for that run of `show_env()`. 

The second line of `show_env()` will capture the environment that is active while the code in `show_env()` runs. This will be the execution environment for `show_env()`.

The last line will return the two results.

### \t

* Click Run Code below a few times to see the results of `show_env()`. 

```{r show, exercise = TRUE}
show_env()
```

Here are a few things to notice:

1. R runs the exercise chunk in a _new_ environment each time you click Run Code (this is how exercise chunks work in a tutorial). These environments will be the calling environments for `show_env()`.
2. R always runs the code body of `show_env()` in a new environment that is not the calling environment. The second result shows the label of this environment, which is the execution environment of `show_env()`.

See the pattern?

### Quiz

What will happen if you run a new line of code after `show_env()`? Here `environment()` will return the environment that is active _after_ `show_env()` finishes running.

* Will this environment be familiar? Why or Why not?
* Clikc Submit Answer to see if you are right.

```{r show2, exercise = TRUE}
show_env()
environment()
```

```{r show2-solution}
show_env()
environment()
```

```{r show2-check}
strict_check("environment() will always return the name of the calling environment because R always makes the calling environment active again after it runs a function. Think of the execution environment as a temporary side trip or errand: R begins in the calling environment, switches to the execution environment, and then returns back to the calling environment.")
```

### The Call Stack

Since one R function can call another R function, an execution environment can become the calling environment for a second execution environment, which could be the calling environment for a third execution environment and so on.

These chains of calling environments are known as the _call stack_. Let's see one in action.

### show_stack()

The `show_stack()` function in the envtutorial package, shows the call stack at the moment it is called. The call stack does not look very impressive when you call `show_stack()` directly from the active environment (which in my case is the global environment):

```{r}
show_stack()
```

So let's embed `show_stack()` in a series of functions. When you run the code below, the `k()` function will call the `j()` function, which will call the `i()` function, which will call `show_stack()`.

* Click Submit Answer to see the call stack that results.

```{r stack1, exercise = TRUE}
i <- function() show_stack()
j <- function() i()
k <- function() j()
k()
```












### Looking up function objects

Execution environments also affect how R will look up values while executing a function. 

As always, R will look for objects in the current active environment, which will be the execution environment while the function code runs. 

Do you remember where R will look next if it does not find an object in the active environment?

### \t

If you said the parent of the active environment you are correct! But what is the parent of an execution environment? Let's find out. 

### \t

First, you will need to know that every function in R knows where it was originally defined. For example, the `date()` function in the lubridate package was originally defined in... the lubridate package environment.

```{r}
environment(date)
```





Here is a function that I defined in the global setup chunk of this tutorial. (In other words, R ran this code when the tutorial first loaded; so `show_execution_par` was defined in a different environment than the active environment of the exercise chunk.)

```{r eval = FALSE}
show_execution_par <- function() {
  env <- environment()
  par <- parent.env(env)
  list(environment = env, parent = par)
}
```

`show_execution_par()` behaves similar to `show_execution_env()`. However, `show_execution_par()` returns a list that contains both the label of the execution environment that R uses to run `show_execution_par()` _and_ the label of the parent of the execution environment.

###  

* Run the code below several times. Then click Submit Answer. 
* What is the parent of the execution environment? 
* Does the parent ever change?

```{r shw2, exercise = TRUE}
environment() # the active environment when you call show_execution_par
show_execution_par()
```

```{r shw2-solution}
environment() # the active environment when you call show_execution_par
show_execution_par()
```

```{r shw2-check}
strict_check("There are two things to notice here: 1) the parent of the execution environment never changes, even though the execution environments change: R creates a new execution environment each time R runs the function, and 2) the parent of the execution environment is NOT the environment that was active when R called show_execution_par().")
```

### Enclosing Environments

The parent of an execution environment will always be _the environment in which the function was originally defined_. This environment is known as the _enclosing environment_ of the function.

A function's enclosing environment never changes. Each time you call the function, R will generate a new execution environment, but each execution environment will use the same enclosing environment as its parent.

You can see a function's enclosing environment by running `environment()` on the function.

* Give it a try. What is the enclosing environment of `show_execution_par`? Click Submit Answer when you are finished.

```{r enclose, exercise = TRUE}

```

```{r enclose-hint}
"Pass show_execution_par as an object name to environment(); don't surround it in quotation marks or follow it with parentheses."
```

```{r enclose-solution}
environment(show_execution_par)
```

```{r enclose-check}
strict_check("This is the same environment that show_execution_par() returns as the parent environment each time you run show_execution_par().")
```

### Search paths

The enclosing environment plays an important role for a function. The enclosing environment determines the function's search path. (Why? Because R will look in the enclosing environment and then the parent of the enclosing environment and so on, if R does not find an object in the execution environment).

If a function was defined in the global environment (or whichever environment the function was called from) then the search path of the environment from which the function was called will align with the search path of the environment in which the function's code is run. **But usually these two search paths do not align.**

In other words, a function will usually not be able to find objects that are defined in your active environment.

###  

Once again, we can see this in action by crafting our ouwn function. I defined `show_path` in the global set up chunk of this tutorial, so `show_path`'s enclosing environment will not be the active environment of the exercise chunk below.

```{r eval = FALSE}
show_path <- function() {
  env <- environment()
  path <- parenvs(all = TRUE)
  list(environment = env, path = path)
}
```

* Run the code below and compare the two search paths.
* Where will the object `a` be defined? 
* Would R be able to find `a` when it runs the code inside `show_path`? Why or why not?
* Click Submit Answer when you are finished.

```{r path, exercise = TRUE}
a <- 1
environment() # The active environment
parenvs(all = TRUE) # the search path from the active environment
show_path() # the search path from the execution environment
```

```{r path-solution}
a <- 1
environment() # The active environment
parenvs(all = TRUE) # the search path from the active environment
show_path() # the search path from the execution environment
```

```{r path-check}
strict_check("The search path for show_path() bypasses the calling environment, which contains a. This raises an important question: how could you pass a to show_path() if show_path() needed to use a? Before we look at the answer, let's summarize R's function evaluation rules.")
```

### Summary

To evaluate a function, R:

1. Creates a new _execution environment_ to use as the active environment while R runs the code in the function's code body.
2. Uses the function's _enclosing environment_ as the parent of the execution environment. The enclosing environment is the environment in which the function was orginially defined. This environment determines the search path that R will use to look up objects while R runs the code in the function's body.
3. Makes the _calling environment_ active again when R has finished running the code in the function body. The calling environment is whichever environment was active when R called the function.