---
title: "Control Flow"
tutorial:
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    highlight: tango
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(grader)
library(lubridate)

grade_learnr <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  strict_check <- function(x) x
  check_code <- eval(parse(text = check_code))
  list(message = check_code, correct = TRUE, location = "append")
}

tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## if and else

### Control Flow

_Control Flow_ refers to the order in which your function executes the statements in its body of code.

By default, R functions will execute each line of code in the body in order, and then return the result of the last line of code. But it doesn't have to be this way. You can write functions that run some code in some situations and other code in other situations. 

Let's learn how!

### if

Take a look at the code below. What is happening? 

```{r}
x <- 1
```

```{r}
x == 1
x > 1
log(x)
if (x == 1) log(x)
```

```{r}
if (x > 1) log(x)
```

Try to describe what `if` is doing in your own words. Your best guess is okay!

### \t

```{r if-quiz, echo = FALSE}
question("Which describes `if`'s behavior? (Check all that apply).",
         answer("`if` takes a logical test and a piece of code. It runs the code _if_ the test returns TRUE.", correct = TRUE, message = "`if` is a way to run code only in certain cases. When you use `if`, you first pass it a logical test surrounded by parentheses and then a piece of code."),
         answer("`if` takes a logical test and a piece of code. It does not run the code _if_ the logical test returns FALSE.", correct = TRUE, message = "`if` will run the piece of code if the logical test returns TRUE and not run the code if the logical test returns FALSE."),
         answer("`if` returns the results of the code that appears in _parentheses_ behind `if`."),
         answer("`if` always executes all of the code that follows it.", message = "`if` will always execute the logical test that appears in parentheses behind `if`. However, `if` will only execute the code that appears after the logical test if the logical test returns TRUE."),
         allow_retry = TRUE)
```

### Data cleaner

Think you have it? Let's check. We'll use `if` to write a useful function.

Many data sets use their own symbols to represent missing values. For example, NOAA will often use `-99` to represent missing values in weather data sets. Let's write a function that checks whether a value is -99, and if so replaces the value with NA.

```{r echo = FALSE}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

```{r}
clean(1)
clean(-99)
```

### \t

Here is a start. `clean()` takes an object and returns the object, but `clean()` is missing an important piece of code.

* Add an `if` statement to the beginning of `clean()`. Your statement should assign NA to x if x equals -99. Then click Submit Answer.

```{r clean-setup}
x <- -99
```

```{r clean, exercise = TRUE}
clean <- function(x) {
  # add if statement here
  x
}
```

```{r clean-hint}
"Don't forget to use == to check for equality."
```


```{r clean-solution}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

```{r clean-check}
strict_check("clean() replaces x with NA if x is -99, otherwise clean() returns x as is.")
```

### else

Here is a second version of `clean()` that relies on a new command: `else`. Can you tell what `else` does?

```{r}
clean <- function(x) {
  if (x == -99) NA else x
}
```

* Run `clean()` with several different values, `22`, `-99`, `3`. What does `clean()` return in each case? Why?

```{r else-setup}
clean <- function(x) {
  if (x == -99) NA else x
}
```

```{r else, exercise = TRUE}

```

### \t

```{r else-quiz, echo = FALSE}
question("Which describes `else`? (Check all that apply).",
         answer("R interprets `else` as a continuation of the `if` statement that immediately precedes it.", correct = TRUE, message = "`else` always follows an `if` statement (if not, `else` returns an error), and R always sees the combined `if` and `else` statements as a single statement."),
         answer("Unlike `if`, `else` does not take a logical test.", correct = TRUE),
         answer("Like `if`, `else` takes a piece of code.", correct = TRUE),
         answer("`else` executes the piece of code if the `if` condition returns FALSE.", correct = TRUE),
         answer("`else` does not execute the piece of code if the `if` condition returns TRUE.", correct = TRUE, message = "Think of a combined `if` `else` statement as a complete description: if the logical test at the start of the statement returns TRUE, R will run the code that follows `if` (but not the code that follows `else`). If the condition returns FALSE, R will run the code that follows `else` (but not the code that follows `if`)."),
         allow_retry = TRUE)
```

### A word about syntax

Although you can put `if` and `else` on the same line, you shouldn't because it is easy for readers to miss the trailing `else` when they scan the code. Also, placing `if` and `else` on the same line can make very long lines.

It would be more common to write our function like this:

```{r}
clean <- function(x) {
  if (x == -99) NA 
  else x
}
```

R parses the `if` and `else` lines as a single statement as long as `else` is the first thing that follows the `if` statement. As a result, R will return the result of the combined if else statement if it appears at the end of a function.

### \{\}

You can also pass `if` and `else` chunks of code surrounded by braces, `{}`. Braces group multiple lines of code into a single "piece." When you use braces in an if else statement, R will run (or not run) everything between the braces.

In this example, R will run all three lines that follow `else` whenever x does not equal -99.

```{r}
clean <- function(x) {
  if (x == -99) {
    NA
  } else {
    x <- x^2
    x <- sqrt(x)
    x
  }
}
```

When you use braces, indent everything between the braces by two spaces to make your code more readable. And of course, you can use braces to organize your code even if you have a single line of code between the braces.

### If else quiz

SAS often saves missing values as `"."`.

* Write a function named `clean2` that takes a value named `x` and returns an NA if the value is `"."` (and returns the value of `x` otherwise).

```{r clean2-setup}
x <- "."
```

```{r clean2, exercise = TRUE}

```

```{r clean2-hint}
"clean2() should closely resemble clean()."
```

```{r clean2-solution}
clean <- function(x) {
  if (x == ".") NA 
  else x
}
```

```{r clean2-check}
strict_check("What if you'd like to check for both -99 and . in the same function?")
```

### else if

In that case, you can use `else` to chain together multiple `if` statements.

```{r eval = FALSE}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else x
}
```

### \t

This as analaogus to 

```{r eval = FALSE}
clean <- function(x) {
  if (x == -99) NA 
  else {
      if (x == ".") NA
      else x
  }
}
```

`clean()` will:

1. Check whether `x == -99`. If so `clean()` will return NA and skip the rest of the code. If not, `clean()` will...
1. Check whether `x == "."`. If so, `clean()` will return NA and skip the rest of the code. If not, `clean()` will...
1. Evaluate `x` and return its value.

`else if` is more readable than nested if else statements, especially if you use many `else if`s.

### \t

You can use `else` to string together as many if statements as you like. R will treat the result as a single multi-part if else statement. 
Be thoughtful with the order. R will always evaluate the clauses in order, executing the code in the _first clause whose condition is true_ and ignoring every clause after that. 

### Your turn

* Write a function named `clean()` that uses `if`, `else`, and `else if` statements to replace the following four values with NA before returning x, `-99`, `"."`, `""`, `"NaN"`. Then click Submit Answer.

```{r clean3-setup}
x <- ""
```


```{r clean3, exercise = TRUE}

```

```{r clean3-solution}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

```{r clean3-check}
strict_check("You can add as many else if after if as you like. However, you cannot add an else if clause after an else because R will interpret the else as the end of a complete if statement.")
```

### Quiz

```{r eval = FALSE}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
foo(1)
```

```{r else-if-quiz, echo = FALSE}
question("What will this code return?",
         answer('"a"', message = "R will not retunr a because the condition 1 > 2 is false."),
         answer('"b"', correct = TRUE, message = 'The condition 1 < 2 is true, so R will evaluate the code that follows it (i.e. "b") and then stop.'),
         answer('"a" "b"', message = "The conditions 1 < 2 and 1 == 1 are both TRUE, but R will stop after the _first_ true condition."),
         allow_retry = TRUE)
```

### Quiz

```{r eval = FALSE}
clean <- function(x) {
  if (x == -99) NA 
  if (x == ".") NA
  if (x == "NaN") NA
  x
}
clean(-99)
```

```{r clean3-quiz, echo = FALSE}
question("What will this code return?",
         answer("NA", message = "Did you notice that the `if` statements are not linked by `else`? What difference does this make?"),
         answer("-99", correct = TRUE, message = "Since the `if` clauses are not linked by `else`, R treats them as separate statements. R checks each if statement. After the first statement it runs NA, but does not return this as the result of the function (because this is not the final statement in the function). R does not run NA for the next two if statements. Then R reaches `x`, which is the last line and last statement in the function. R evaluates `x`, which equals -99, and returns -99 as the result of the function."),
         allow_retry = TRUE)
```

### Congratulations!

You now know how to use `if` and `else` in your code. Let's look at another way to control flow in R.

## return() and stop()

### \t

You can tell R to stop executing a function early with 

* `return()`
* `stop()`, and
* `stopifnot()`

Each will only work in the context of a function (because they stop the function). You wouldn't run these directly at the command line, but they provide a powerful way to control the flow of your functions. They can make if else statements unnecessary and can even make your code less buggy.

### return()

When R encounters `return()` it will stop executing the function that called `return()`. If you pass a value to `return()`, R will return that value when it stops executing the function. Let's see how it works.

```{r}
impatient_square <- function(x) {
  return(x)
  x^2
}
```

```{r return-quiz, echo = FALSE}
question("Which value will `impatient_square(2)` return?",
         answer("2", correct = TRUE, message = "R stops executing `impatient_square()` and returns `x` when R encounters `return(x)`. It doesn't matter that `return(x)` is not the last line of the function."),
         answer("4", message = "R stops executing `impatient_square()` when it encounters `return(x)`. As a result, R does not evaluate `x^2`."),
         allow_retry = TRUE)
```

### R with a python accent

If you are a python user, you may already be using `return()` in your R code unnecessarily. In python, you explicitly tell each function what to return, e.g. 

```python
def mysquare(x):
  y = x * x
  return y
```

Translated to R this becomes:

```{r}
my_square <- function(x) {
  y <- sum(x) / length(x)
  return(y)
}
```

But in R, this return is not needed. R functions automatically return the result of their last line of code. In R, you can save return for unusual control flow.

### Using return()

Remember this function? IT didn't work as eexpected because we forgot to link our if statements with `else`.

* Fix the function not by adding `else`, but by adding `return()` in the right places. Then Click Submit Answer.

```{r return, exercise = TRUE}
clean <- function(x) {
  if (x == -99) NA 
  if (x == ".") NA
  if (x == "NaN") NA
  x
}
```

```{r return-solution}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r return-check}
strict_check("This version is slightly easier to read than a linked if else tree because you can think about each if clause separately. You can often avoid long, nested if else trees by using return thoughtfully.")
```

### NULL

`clean()` is a fairly useful function, but it does have one flaw. 

* What happens when `x = NULL`. Click Submit Answer and find out.

```{r null, exercise = TRUE}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
clean(NULL)
```

```{r null-solution}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
clean(NULL)
```

```{r null-check}
strict_check("clean() cannot handle NULL because if returns an error when it evaluates `NULL == -99`. And, unfortunately, the error message isn't very clear. This is the perfect case for `stop()`.")
```

### stop()

`stop()` behaves like `return()`, but instead of returning a value, `stop()` returns an error, complete with a custom error message. Can you tell how it works?

```{r eval = FALSE}
immovable_square <- function(x) {
  stop("I refuse to proceed.")
  x^2
}
```

```{r stop-quiz, echo = FALSE}
question("What does `immovable_square(2)` return?",
         answer("4", message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed.")`.'),
         answer("Error in immovable_square(2) : I refuse to proceed.", correct = TRUE, message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed. The error message will look just like this; R inserts the message tht you pass as a character string to `stop()`.'),
         allow_retry = TRUE)
```

### \t

* Use if and `is.null()` to add a `stop()` call at the beginning of `clean()`. The command should return the error message `"x is NULL"` whenever x is NULL. 
* Then click Submit Answer.

```{r stop, exercise = TRUE}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stop-solution}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stop-check}
strict_check("Now `clean()` can handle NULL values in an intelligent way. This pattern (if + stop) is so common that R provides a shortcut for it, `stopifnot()`.")
```

### stopifnot()

`stopifnot()` is a more readable substitute for statements that combine `if` and `stop`. Can you guess how it works?

```{r stopifnot-quiz, echo = FALSE}
question('Which of these does the equivalent of `if (x < 0) stop("x is less than zero")`?',
         answer('`stopifnot(x < 0)`', message = "Good guess! But the function isn't called `stopif()`; it's called `stopifnot()`."),
         answer('`stopifnot(x >= 0)`', correct = TRUE),
         allow_retry = TRUE)
```

### differences

`stopifnot()` is different from `if` + `stop()` in a few important ways: 

1. Instead of checking whether a condition is met, `stopifnot()` checks whether a condition is _not_ met.
1. `stopifnot()` does not pass along a custom error message. Instead, `stopifnot()` always explains that the condition was not true,
    ```{r}
    x <- -1
    stopifnot(x >= 0)
    ```

Notice that the first argument of `stopifnot()` should always be a logical condition, the inverse of the condition it replaces in the `if` + `stop()` statement.

### \t

Think you have it? 

* Try replacing the `if` + `stop()` statement in `clean()` with `stopifnot()`. Then click Submit Answer.

```{r stopifnot, exercise = TRUE}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-hint}
"You can reverse the result of `is.null()` by placing an `!` in front of it: `!is.null()`."
```

```{r stopifnot-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-check}
strict_check("stopifnot() is both very readable and very useful. Click Continue to see why.")
```

### Defensive programming with stopifnot()

You can save yourself debugging time by writing your functions to _fail fast_ with clear error messages. To do this, think about situations that will lead to errors and then check for them with `stopifnot()` at the beginning of your code.

If things go wrong, `stopifnot()` will help you see what you need to fix as soon as you run your function. Compare this to what will happen if you do not use `stopifnot()`:

1. Your code will run until it triggers a (perhaps unhelpful) error message
1. Your code may not trigger an error message. Instead it might return an incorrect result that you will think is true. This would be a very bad outcome.

## && and ||

### \t

Here's what `clean()` looks like. Do you notice that all of the `if` statements have the same outcome? 

```{r eval = FALSE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

### \t 

Let's use your knowledge of logical tests to trim them down to a single if statement. 

* Write a logical test that returns TRUE when x is -99 OR x is "." (we will ignore the "NaN" case to keep things simple. Then click Submit Answer.

```{r logic, exercise = TRUE}

```

```{r logic-hint}
"You can combine two logical tests in R with `&` (and) and `|` (or), e.g. x < 0 & x > 1."
```

```{r logic-solution}
x == -99 | x == "."
```

```{r logic-check}
"This is the correct way to combine logical tests in R, but it has some downsides when you use it with `if` statements."
```

### & and |

`&` and `|` are R's boolean operators for combining logical tests.

* `&`, which stands for "and" will return `TRUE` if _both_ tests return `TRUE` and will return `FALSE` otherwise. 
* `|`, which stands for "or" will return `TRUE` if _one or both_ tests returns `TRUE` and will return `FALSE` otherwise. So,

```{r}
x <- -99
x == -99 | x == "."
```

### \t

However, it is bad practice to use `&` and `|` to combine logical tests within an `if` condition. Why? Because

1. there is something better (as you'll see in a minute)
1. `&` and `|` tend to generate warning messages when used with `if`

### \t 

As R operators, both `&` and `|` are vectorized. As a result, you can use them with vectors, which is very useful.

```{r}
x <- c(-99, 0 , 1)
x == -99
x == "."
x == -99 | x == "."
```

### \t

However, `if` conditions are not vectorized. `if` expects the logical test contained within its parentheses to return a _single TRUE or FALSE_. If the condition returns a vector of `TRUE` or `FALSE`s, `if` will use the first value and show a warning message.

```{r}
x <- c(-99, 0 , 1)
if (x == -99 | x == ".") NA
```

### && and ||

You can avoid this by always using `&&` and `||` within your `if` conditions. `&&` and `||` are lazy substitutes for `&` and `|`. They are lazy in two ways:

1. When given vectors, `&&`and `||` will only compare the first elements of the vectors (and not return a warning message).
1. When possible, `&&` and `||` will jump to the correct conclusion without evaluating the second logical test (not so with `&` and `|`. 
    * `&&` will return `FALSE` if the logical test on the left returns `FALSE` (because the combined test would return `FALSE`). 
    * `||` will return `TRUE` if the logical test on the left returns `TRUE` (because the combined test would return `TRUE`)
    
    ```{r}
x <- c(-99, 0 , 1)
x == -99 || x == "."
if (x == -99 || x == ".") NA
```
    
### Use ||

* Replace the two `if` statements below with a single statement that tests whether x is `-99` or `"."` without throwing error messages.

```{r or, exercise = TRUE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  x
}
```

```{r or-hint}
"Like |, || expects a _complete_ logical test on each side of ||."
```

```{r or-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

```{r}
strict_check("Now lets see what happens if you use clean() with a vector of values.")
```

### \t

```{r eval = FALSE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

```{r}
question("What will `clean(c(-99, 0, 1))` return?",
         answer("NA 0 1", message = "The logical test will only consider the first value of the vector x, which here contains c(-99, 0, 1). Since that value is -99, the logical test will return TRUE and R will execute the code `return(NA)`, which returns a single NA."),
         answer("NA _with_ a warning message", message = "You certainly would get a warning message if your logical test used |, which will pass a vector of TRUEs and FALSEs to if, triggering the message. However, || will only pass on a single TRUE or FALSE."),
         answer("NA _without_ a warning message", correct = TRUE),
         answer("an error"),
         allow_retry = TRUE)
```

### \t

So we've avoided the warning message, but this isn't the most important reason for using `||` instead of `|`. (In fact, you might consider it an anti-reason. You might want a warning that something weird is going on if you accidentally pass a vector of values to `clean()`, but you could screen for that with `stopifnot(length(x) == 1)` if that bothers you.)

The most important reason is that `||` saves unnecessary computation when possible. Remember the second quality of `&&` and `||`? You will!

Remember how this code returns an error because `if` cannot handle the result of `NULL == -99`?

```{r}
clean <- function(x) {
  if (x == -99) return(NA)
  x
}
clean(NULL)
```

### Quiz

Let's redefine `clean()`.

```{r eval = FALSE}
clean <- function(x) {
  if (is.null(x) || x == -99) return(NA)
  x
}
```

```{r null-quiz, echo = FALSE}
question("Now what will `clean(NULL)` return?",
         answer("An error", message = "clean() certainly would return an error if it evaluated `x == -99` (and collapsed the results into a single result to pass to if), but _does_ `clean()` evaluate `x == -99`?"),
         answer("NA", correct = TRUE, message = "|| first evaluates `is.null(x)` this is a problem free command that returns `TRUE`. Then `||` stops and returns `TRUE` to `if` because an or statement is always true when the first test is true. As a result, R never evaluates the code that leads to an error."),
         allow_retry = TRUE)
```

## Vectorized if

### \t

The last section suggests an interesting question: what if you did want `clean()` to work with vectors of values? i.e.

```{r echo = FALSE}
clean <- function(x) ifelse(x == -99, NA, x)
```

```{r}
clean(c(-99, 0, 1))
```

That would be a handy way to clean whole columns of data! How could you do it?

### \t 

Compare these two functions (one should seem familiar). What is different?

```{r}
clean <- function(x) {
  if (x == -99) NA else x
}

clean2 <- function(x) {
  ifelse(x == -99, NA, x)
}
```

```{r ifelse-quiz, echo = FALSE}
question("Make a guess: do these two functions do the same thing?",
         answer("Yes!", correct = TRUE, message = "Well, you are sort of correct..."),
         answer("No!", correct = TRUE, message = "Well, you are sort of correct..."),
         answer("Sort of...", correct = TRUE, message = "You are absolutely right."), 
         allow_retry = TRUE)
```

### ifelse()

`ifelse()` is a function that replicates an if/else statement. It takes three arguments: a logical test followed by two pieces of code. If the test returns `TRUE`, `ifelse()` will return the results of the first piece of code. If the test returns `FALSE`, `ifelse()` will return the results of the second piece of code. 

So `clean(-99)` and `clean2(-99)` both return `NA`.

```{r}
clean(-99)
clean2(-99)
```

### \t

However, unlike `if` and `else`, `ifelse` is vectorized. As a result, you can pass `ifelse()` a vector of values and it will apply the implied if / else statement separately to each element of the vector.

```{r}
x <- c(-99, 0, 1)
ifelse(x == -99, NA, x)
```

`clean2()` inherits this vectorized property. Compare that to `clean()` (which is inherently non-vectorized because it relies on the non-vectorized `if` and `else` constructors.

```{r}
clean(c(-99, 0, 1))
clean2(c(-99, 0, 1))
```

### if_else

The dplyr package offers a slight improvement on `ifelse()` named `if_else()`. `if_else()` is faster than `ifelse()` because it requires you to ensure that each case returns in the if/else statement returns the same type of object. For example, the statement needs to return a real number _whether or not_ the condition is `TRUE` (or a string, or a logical, etc.).

No big deal, right? Well kind of.

```{r}
x <- c(-99, 0, 1)
if_else(x == -99, NA, x)
```

### NA

Recall that data in R comes in six atomic types. 

```{r type-quiz, echo = FALSE}
qusetion("What type of data is NA?",
         answer("double (i.e. real numbers)"),
         answer("integer"),
         answer("character"),
         answer("logical", correct = TRUE, message = "It turns out that if you type NA at the command line, R saves the result as a logical."),
         answer("complex"),
         answer("raw"),
         allow_retry = TRUE)
```

### \t

It is true:

```{r}
typeof(NA)
```

So when you write `if_else(x == -99, NA, x)`, `if_else()` returns a logical in the first case and a double (real number) in the second (assuming `x` is a real number). 

You can get around this mishap in two ways:

1. Stick to `ifelse()`
1. Use a NA that comes with a type

### Types of NA

You may not realize it, but R comes with five types of NA. They all appear as `NA` when printed, but they are each saved with a separate data type. These are:

```{r}
NA # logical
NA_integer_ # integer
NA_real_ # double
NA_complex_ # complex
NA_character_ # character
```

You can fix `if_else()` by being precise about which NA to use (most other R functions will convert the type of NA without bothering you).

```{r}
x <- c(-99, 0, 1)
if_else(x == -99, NA_real_, x)
```

### Use if_else

* Fix the `if_else()` statement of `clean2()` to work with real numbers. Then click Submoit Answer.

```{r cleans, exercise = TRUE}
clean2 <- function(x) {
  ifelse(x == -99, NA, x)
}
```

```{r cleans-solution}
clean2 <- function(x) {
  ifelse(x == -99, NA_real_, x)
}
```

```{r cleans-check}
strict_check("What if you want `clean2()` to work with all types of data? That's simple: stick with `ifelse()`.")
```

### \t

What if you want to write a vectorized version of a multi-part if/else tree? Like the tree in this function:

```{r eval = FALSE}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

In this case, neither `ifelse()` or `if_else()` will do. Why? Because each can only handle a single if condition, but our tree has four.

### case_when()

You can vectorize multi-part if/else statements with dplyr's `case_when()` function. Here is how we would use `case_when()` to rewrite our `foo()` function.

Here is the masterpiece in its original form

```{r}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
```

And here it is with `case_when()`.

```{r}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE   ~ "d"
  )
}
```

### \t

And here are our foos in action to prove that `foo2()` is vectorized.

```{r}
x <- c(1, 2, 3)
foo(x)
foo2(x)
```

Notice that 

1. `case_when()` returns a single case for each element, the first case whose left hand side evaluates to `TRUE`
1. The left hand side of the last case evaluates to `TRUE` no matter what the value of `x` (heck the left hand side _is_ `TRUE`). This is an easy way to add an `else` clause to the end of `case_when()`.

Now let's look at the unusual syntax of `case_when()`.

### case_when() syntax

```{r eval = FALSE}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE   ~ "d"
  )
}
```

Each argument of `case_when()` is a pair that consists of a logical test on the left hand side and a piece of code on the right hand side. The two are _always_ separated by a `~`.

Like `if_else()`, `case_when()` expects each case to return the same type of output. So keep those NA types handy: `NA`, `NA_integer_`, `NA_real_`, `NA_complex_`, `NA_character_`.

### Final Challenge

* Rewrite the multi-part version of `clean()` to use `case_when()`, which will allow `clean()` to handle vectors. Retain each case. Assume where necessary that `clean()` will only work with real numbers. Then click Submit Answer.

```{r when, exercise = TRUE}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

```{r when-hint}
"Use NA's that have the right type."
```

```{r when-solution}
clean <- function(x) {
  case_when(
    x == -99 ~ NA_real_, 
    x == "." ~ NA_real_,
    x == "" ~ NA_real_,
    x == "NaN" ~ NA_real_,
    TRUE ~ x
  )
}
```

```{r when-check}
strict_check('And if you noticed that a vector of real numbers would never contain ".", "", and "Nan" because they are strings, you are of course right. Thanks for playing along with the charade.')
```

### Congratulations!

You've learned how to alter the control flow of your functions with:

* `if`
* `else`
* `return()`
* `stop()`
* `stopifnot()`
* `ifelse()`

Not only that, you tackled two advanced methods: dplyr's `if_else()` and dplyr's `case_when()`.


