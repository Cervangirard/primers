---
title: "More Map"
tutorial:
  id: "io.shinyapps.tutorials.more-map"
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: false
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(tidyverse)
library(repurrrsive)


gap_dfs <- gap_split %>% map(select, -1, -2)
gap_list <- gap_dfs %>% map(as.list)

us <- gap_list %>% pluck("United States")
list1 <- list(numbers = 1:3, letters = c("a", "b", "c"), logicals = c(TRUE, FALSE))
lists <- list("norm" = list("mu" = 0, "sd" = 1),
              "lnorm" = list("mu" = 1, "sd" = 1),
              "cauchy" = list("mu" = 2, "scale" = 1))

model1 <- gap_dfs %>% 
  map(~lm(lifeExp ~ year, data = .x))

model2 <- gap_dfs %>% 
  map(~lm(lifeExp ~ year + gdpPercap, data = .x))

model3 <- gap_dfs %>% 
  map(~lm(lifeExp ~ year + gdpPercap + pop, data = .x))


checker <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  list(message = check_code, correct = TRUE, location = "append")
}
tutorial_options(exercise.timelimit = 60, exercise.checker = checker)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```


## Why More?

### \t

In the Map tutorial, you learned how to use purrr's map functions. In this tutorial, you will learn how to use them _well_.

The map functions come with several very useful shortcuts as well as new functions that let you map over two or more vectors, or even a vector of functions. 

### Data 

Let's start with a real data set.

`us` is a list of statistics about the US, measured every five years from 1952 to 2007. It is a reformatted portion of the `gapminder` data set, which comes in the gapminder package. 

* Click Submit Answer to see the contents of `us`. Can you spot the life expectancy for a US citizen in 1952? How about in 2007?

```{r us-1, exercise = TRUE}
us
```

```{r us-1-solution}
us
```

```{r us-1-check}
"Good job. Life expectancy statistics are saved in the second element of us: the element named lifeExp. The first number in lifeExp is the life expectancy in 1952, the last number is the life expectancy in 2007. Ideally, you'd encounter this type of data in a data frame, but it is possible to receive messy data like this."
```

### \t

Now, let's use the values of the `lifeExp` element in `us` to compute the rise in life expectancy from 1952 to 2007. 

This is a simple task, but we can use it as the basis of an iteration project.

### Data Wrangling 

The values of `us$lifeExp` are difficult to work with because they are stored inside of a list (`us`). You can extract them with purrr's `pluck()` function. 

`pluck()` extracts an element from a list, by name or by position, e.g. `pluck(list1, 1)`, `pluck(list1, "numbers")`.

* Use `pluck()` to extract the contents of `lifeExp` from `us`. Then click Submit Answer. I've pre-loaded the purrr package for you.

```{r pluck, exercise = TRUE}

```

```{r pluck-hint-1}
"The name of the element that you want to pluck is lifeExp."
```

```{r pluck-hint-2}
"Don't forget to put quotes around lifeExp when you pass it to pluck()."
```

```{r pluck-solution}
us %>% pluck("lifeExp")
```

```{r pluck-check}
'Nice. pluck() does the same thing as us$lifeExp and us[["lifeExp"]], but pluck() is easier to read (and easier to pass to map()).'
```

### Rise in lifeExp

* Use `last()` and `first()` to compute the rise in life expectancy in the US from 1952 to 2007. Both come in the dplyr package, which I've pre-loaded for you.
    1. `last()` extracts the last element of a vector. 
    1. `first()` extracts the first element of a vector. 

* Then click Submit Answer.

```{r us-2, exercise = TRUE}
lifeExp <- us %>% pluck("lifeExp")

```

```{r us-2-hint}
"The change in life expectancy will be the last value of lifeExp minus the first value of lifeExp."
```

```{r us-2-solution}
lifeExp <- us %>% pluck("lifeExp")
last(lifeExp) - first(lifeExp)
```

```{r us-2-check}
"Excellent. The life expectancy of US citizens increased by 9.8 years between 1952 and 2007."
```

### Recap

Useful right? Let's recap what you did:

1. You plucked the `lifeExp` values from `us` with `pluck()`
2. You computed the change over time with `last(lifeExp) - first(lifeExp)`

### \t

It'd be nice to do this for other countries as well.

Guess what? You can. `gap_list` contains lists of statistics for 142 countries. Click Submit Answer to see. 

```{r gap_list, exercise = TRUE}
gap_list
```

```{r gap_list-check}
"To iterate through these, you will need to use map functions---and their shortcuts."
```


## Shortcuts

### \t

Let's map your work to `gap_list`. For each country in `gap_list`, you will need to

1. Pluck the values of `lifeExp` from the sub-list that contains them
2. Compute the change over time with `last(lifeExp) - first(lifeExp)`

Each step will reveal new aspects of the map functions. 

* Step 1 will demonstrate two useful shortcuts
* Step 2 will demonstrate how to make and apply expressions with map functions

### Step 1

Recall that `gap_list` is a list whose elements are sub-lists. Each sub-list is identical in structure to `us`.

* Map `pluck()` over `gap_list` to return a list of the lifeExp vectors of each country in `gap_list`.

```{r gap_pluck, exercise = TRUE}

```

```{r gap_pluck-hint}
"Recall that map() takes a vector to iterate over, a function to apply to each element of the vector, and then any arguments that that function needs."
```

```{r gap_pluck-solution}
gap_list %>% map(pluck, "lifeExp")
```

```{r gap_pluck-check}
"Nice! As always, I recommend that you use R's pipe syntax whenever possible (%>%). Pipes make it easy to build upon your work, concentrating on one step at a time."
```

### shortcuts

You now have your vectors where you want them; but before we go on, consider what you did.

### \t

Your list (`gap_list`) contained 142 sub-lists, and each sub-list contained the same set of elements. This set up is more common than you may think. 

You pulled out the same element from each of those sub-lists. This operation is more common than you might think.

In fact, this operation is so common that `map()` provides two shortcuts to help you do it.

### "" shortcut

First, you can pass `map()` the name of an element to extract. Pass the name as a simple character string, e.g. `map(lists, "mu")` or `lists %>% map("mu")`.

When `map()` receives a character string instead of a function, it will extract the element of each sub-list whose name matches the character string.

* Try it with `gap_lists`. Change the code below to use the "" shortcut. Then click Submit Answer. Do you get the same result?

```{r quotes, exercise = TRUE}
gap_list %>% map(pluck, "lifeExp")
```

```{r quotes-hint-1}
"Did you remember to remove pluck from the map() call?"
```

```{r quotes-hint-2}
"The element that you want to extract from each sub-list is named lifeExp."
```

```{r quotes-solution}
gap_list %>% map("lifeExp")
```

```{r quotes-check}
"Excellent. I prefer to use this shortcut, but there is also a second, even shorter shortcut that extracts elements from sub-lists. Click Continue to find out what it is."
```

### Integers shortcut

Instead of passing `map()` a character string that identifies the element to extract by name, you can pass `map()` an integer that identifies the element to extract by position, e.g. `map(lists, 1)` or `lists %>% map(1)`.

Do you remember the position of `lifeExp` within each sub-list of `gap_list`? It is the second element. 

* Use this info to extract `lifeExp` with the new shortcut. Then click Submit Answer.

```{r integer, exercise =TRUE}
gap_list
```

```{r integer-hint}
"Use map() and pass it a number."
```

```{r integer-solution}
gap_list %>% map(2)
```

```{r integer-check}
"Great job. Like I said, I prefer to spell out the whole name of the element. That way I don't need to remember the position of the element, nor do I need to worry that the elements may be out of order in one of the sub-lists."
```

### Data frames

The best thing about these shortcuts is that they also work when your list contains data frames. You can use the shortcuts to pull out the same column of each data frame.

For example, `gap_dfs` contains the same information as `gap_lists`, but it organizes each sub-list into data frame, which is more user-friendly.

* Click Run Code to see what I mean.

```{r gap_dfs, exercise = TRUE}
gap_dfs
```

### \t

* Use the "" shortcut to extract the `lifeExp` column of each sub-data frame in `gap_dfs`. Then click Submit Answer. What happens?

```{r gap_dfs-1, exercise = TRUE}
gap_dfs
```

```{r gap_dfs-1-solution}
gap_dfs %>% map("lifeExp")
```

```{r gap_dfs-1-check}
'The "" shortcut works with data frames. So will the integer shortcut. And the reason is simple: in R data frames are a type of list, just like tibbles are a type of data frame. As a result, things that work with lists will also work with data frames.'
```

### One more thing

There is one more thing that you should know about these shortcuts. In the Map tutorial, you learned that `map()` is part of a larger family of map functions:

Function     | Output
------------ | -------------
`map()`      |  list
`map_chr()`  |  character vector
`map_dbl()`  |  double (numeric) vector
`map_dfc()`  |  data frame (output column binded)
`map_dfr()`  |  data frame (output row binded)
`map_int()`  |  integer vector
`map_lgl()`  |  logical vector
`walk()`     |  returns the input invisibly (used to trigger side effects)

The "" and integer shortcuts will work with all of these functions. So will the expressions that you are about to learn. Speaking of that, let's get back to your analysis.


## Expressions

### \t

Recall your goals:

1. Pluck the values of `lifeExp` from the sub-lists that contain them
2. Compute the change over time with `last(lifeExp) - first(lifeExp)`

Step 1 was easy and you learned two shortcuts along the way, but Step 2 will be harder.

### Step 2

You know that you can use `map()` to apply a function to each element of a list, but `last(lifeExp) - first(lifeExp)` isn't a function. It is an expression that uses two functions. How can you pass it to `map()`?

Here is where expressions come in.

### A pattern

At the heart of `map()` is the pattern:

For each element, do _____

### \t

When we fill in the blank with a function, or a character string, or an integer, `map()` knows just what to do.

But you can also fill in the blank with an arbitrary R expression (like `last(lifeExp) - first(lifeExp)`) as long as you follow two rules.

### Rule 1 - ~

First, place a `~` at the start of the expression. This alerts `map()` that you are giving it an expression to run:

For each element, do `~last(lifeExp) - first(lifeExp)`

### Rule 2 - .x

Second, replace the _name of the thing to manipulate_ with `.x` wherever it appears in your expression.

For each element, do `~last(.x) - first(.x)`

Or more simply,

For each `.x`, do `~last(.x) - first(.x)`

This tells `map()` where to use the element within your expression. If an expression uses each element multiple times, you will need to insert multiple `.x`s into your expression.

### \t

How does this look with the `map()` function? You pass the expression to `map()` exactly as you would pass a function.

Here is an example, the expression plucks the two values in each sub-list of `lists` and uses them to generate five random normal values.

* Click Submit Answer to see the results.

```{r rnorm, exercise = TRUE}
map(lists, ~rnorm(5, mean = pluck(.x, 1), sd = pluck(.x, 2)))
```

```{r rnorm-hint}
"Leave the code as is and click Submit Answer."
```

```{r rnorm-solution}
map(lists, ~rnorm(5, mean = pluck(.x, 1), sd = pluck(.x, 2)))
```

```{r rnorm-check}
"Nice. Don't be confused by the names, all of these numbers come from a normal distribution."
```

### Use it

Now it is your turn. To finish your code: 

1. Turn `last(lifeExp) - first(lifeExp)` into an expression.
2. Use `map()` to apply the expression to each element returned by the code below. 
3. Then click Submit Answer.

```{r exp, exercise = TRUE}
gap_list %>% 
  map("lifeExp")
```

```{r exp-hint-1}
"Use %>% to add a second map() call to your code."
```

```{r exp-hint-2}
"Remember the two rules for map expressions: 1) begin with a ~, 2) refer to the elements with .x. Do not surround the expression with quotes."
```

```{r exp-solution}
gap_list %>% 
  map("lifeExp") %>% 
  map(~last(.x) - first(.x))
```

```{r exp-check}
"Great job. You can do almost anything with map() if you use the right expression."
```

### Beyond map()

You are on a roll! What if you'd like the result to come back as a double (numeric) vector?

* Change the code below to return a double vector in the last step. Will the expression still work? Click Submit Answer to find out.

```{r dbl-exp, exercise = TRUE}
gap_list %>% 
  map("lifeExp") %>% 
  map(~last(.x) - first(.x))
```

```{r dbl-exp-solution}
gap_list %>% 
  map("lifeExp") %>% 
  map_dbl(~last(.x) - first(.x))
```

```{r dbl-exp-check}
"You bet it works. Just like the shortcuts you learned earlier, expressions work with all of the map functions."
```

### A small payoff

You now have your results as a named numeric vector. Success!

Even though it is not related to `map()`, it would be rewarding to learn which countries had the largest and smallest changes in life expectancy. Let's take a moment to find out. You'll learn three useful functions along the way.

### \t

Here are three functions that can help.

1. `enframe()` turns a named vector into a data frame with two columns: `name` and `value`. 

    ```{r}
    named_vec <- c(uno = 1, dos = 2, tres = 3)
    enframe(named_vec)
    ```
    
    
    `enframe()` comes in the tidyr package, which I've pre-loaded for you.
    
### \t

2. `top_n()` returns the n rows that have the highest value of a weighting variable. 

    ```{r}
    top_n(mtcars, n = 5, wt = mpg)
    ```
    
    (Don't be fooled: these are the rows with the five highest values of `mpg`. `top_n()` retrieves them but does not sort them by `mpg`).


### \t

3. You can combine `top_n()` with `desc()` to retrieve the lowest n values.

    ```{r}
    top_n(mtcars, n = 5, wt = desc(mpg))
    ```
    
    Both `top_n()` and `desc()` come in the dplyr package.

### The most extreme changes in life expectancy

* Extend your code with `enframe()` and `top_n()` to retrieve the five countries with the _greatest_ change in life expectancy. Then click Submit Answer.

```{r greatest, exercise = TRUE}
gap_list %>% 
  map("lifeExp") %>% 
  map_dbl(~last(.x) - first(.x))
```

```{r greatest-hint-1}
"To begin pipe your results into enframe()." 
```

```{r greatest-hint-2}
"...i.e. add %>% enframe() to the end of your code." 
```

```{r greatest-hint-3}
"Then pipe that result to top_n(). You will need to set the n and wt arguments of top_n()." 
```

```{r greatest-hint-4}
'enframe() named the column that you want to wt by "value".' 
```

```{r greatest-solution}
gap_list %>% 
  map("lifeExp") %>% 
  map_dbl(~last(.x) - first(.x)) %>% 
  enframe() %>% 
  top_n(5, wt = value)
```

```{r greatest-check}
"Excellent. Oman, Vietnam, Indonesia, Saudi Arabia, and Libya had the highest increases. Now what about the countries with the lowest increases?"
```

### \t

* Add `desc()` to your code to retrieve the five countries with the smallest increase in life expectancy. Then click Submit Answer.

```{r least, exercise = TRUE}
gap_list %>% 
  map("lifeExp") %>% 
  map_dbl(~last(.x) - first(.x)) %>% 
  enframe() %>% 
  top_n(5, wt = value)
```

```{r least-hint}
"This time, you want to order by descending values of value."
```

```{r least-solution}
gap_list %>% 
  map("lifeExp") %>% 
  map_dbl(~last(.x) - first(.x)) %>% 
  enframe() %>% 
  top_n(5, wt = desc(value))
```

```{r least-check}
"Two countries actually decreased their life expectancy: Zimbabwe and Swaziland. I hope you found this interesting, but let's get back to map expressions."
```

### Expression best practices

The best way to write an expression is to:

1. Pluck a single element from your list
2. Write code that works correctly for that element
3. Transform the code into an expression to use with `map()`

The alternative is to write an expression in your head, and then see if it works. Too often it won't. 

### Models 

Let's put this workflow into practice. 

Another way to quantify the change in life expectancy over time is to fit a simple linear model to the data. 

The slope of the model will be how fast life expectancy increased per year, on average.

### Step 1

The first step of the expression workflow is:

1. Pluck a single element from your list

Why not begin with the US? To make life simpler we will use `gap_dfs` instead of `gap_list`.

* Pluck the "United States" element from `gap_dfs`. Save it as `usa` (so you don't overwrite `us`). Then click Submit Answer.

```{r usa, exercise = TRUE}

```

```{r usa-hint}
"You do not need to use map() here, just pluck()."
```

```{r usa-solution}
usa <- gap_dfs %>% pluck("United States")
```

```{r usa-check}
"This single case will be your test case: you can run your code on it to spot any bugs as soon as they arise."
```

### Step 2

Next,

2. Write code that works correctly for that element

I'm not sure if you've ever fit a linear model with R before, so I'll just tell you: this is the code that we want (below). 

* Click Submit Answer to ensure that it works on your test case with no problems.

```{r lm-setup}
usa <- gap_dfs %>% pluck("United States")
```

```{r lm, exercise = TRUE}
lm(lifeExp ~ year, data = usa)
```

```{r lm-hint}
"Leave the code as is and click Submit Answer."
```

```{r lm-solution}
lm(lifeExp ~ year, data = usa)
```

```{r lm-check}
"Life expectancy increased on average by 0.18 years per year for the US. Great. This is the code to map over gap_dfs, but first..."
```

### Step 3

Finally,

3. Transform the code into an expression to use with `map()`

* Turn your code into an expression and `map()` it to each element of `gap_dfs`. Then click Submit Answer.

```{r lm-map-setup}
usa <- gap_dfs %>% pluck("United States")
```

```{r lm-map, exercise = TRUE}
lm(lifeExp ~ year, data = usa)
```

```{r lm-map-hint-1}
"Begin with gap_dfs and pass it to map()."
```

```{r lm-map-hint-2}
"The next argument of map() should be your function, rewritten as an expression. Do you remember the two rules for writing map expressions?"
```

```{r lm-map-hint-3}
"Rule 1: begin the expression with a ~."
```

```{r lm-map-hint-4}
"Rule 2: replace every appearance of the element to use with .x. In our code, each element would iteratively take the place of usa."
```

```{r lm-map-solution}
gap_dfs %>% 
  map(~lm(lifeExp ~ year, data = .x))
```

```{r lm-map-check}
"Excellent! I've gone ahead and saved your results as a list named model1. Let's practice this workflow one last time, but this time with no guidance from me."
```

### A model that accounts for GDP

* Repeat your previous work, but this time use `lifeExp ~ year + gdpPercap` as the formula inside of `lm`. Begin by testing out your code on your test case, which is `usa`. When you are finished fitting the models, click Submit Answer.

```{r lm-map2-setup}
usa <- gap_dfs %>% pluck("United States")
```

```{r lm-map2, exercise = TRUE}

```

```{r lm-map2-solution}
gap_dfs %>% 
  map(~lm(lifeExp ~ year + gdpPercap, data = .x))
```

```{r lm-map2-check}
"Great work. I've saved this result for you as model2. I recommend using this workflow every time you write a map expression. Now let's look at some new features of map."
```

## Multiple Vectors

### \t

In the last section, you computed two models for every country:

1. One that predicted life expectancy by year, which I saved as `model1`.
1. One that predicted life expectancy by both year _and GDP per capita_, which I saved as `model2`.

Does adding GDP per capita improve your predictions for life expectancy?

### anova() 

One way to tell is with the `anova()` function. `anova()` takes two models and tests whether the second model outperforms the first.

Let's try it. We can use our two models for the United States

```{r}
usa_mod1 <- model1 %>% pluck("United States")
usa_mod2 <- model2 %>% pluck("United States")
```

### \t

The anova results suggest that adding GDP per capita did _not_ improve your predictions for the US. 

How can you tell? The very last number in the table is a p-value (here 0.1424). If the number is above 0.05, there's not enough evidence to suggest that the second model outperforms the first: you can ascribe the difference between the two to random chance.

```{r}
anova(usa_mod1, usa_mod2)
```

### Beyond the US

So GDP per capita doesn't improve your predictions for the United States, but what about for the other countries? 

You can iterate through all of the countries to find out, but this is a new type of iteration problem. At each step, `anova()` will require one element from `model1` and one element from `model2`. You'll need to simultaneously iterate over _two_ lists.

### map2()

Enter `map2()`.

Syntactically, `map2()` behaves like `map()`, but it takes _two_ vectors as arguments before it takes a function (remember that lists are a type of vector). 

At each step of the iteration, `map2()` will pass an element from the first vector to the first argument of the function. It will pass an element from the second vector to the second argument of the function.

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("www/images/map2.png")
```

### \t

* Use `map2()` to run an anova on each pair of models in `model1` and `model2`. Then click Submit Answer.

```{r map2, exercise = TRUE}

```

```{r map2-solution}
map2(list1, list2, anova)
```

```{r map2-check}
"Nice job! A quick scan of the results suggests that adding gdpPercap only improved your predictions for the poorest countries."
```

### map2() and map()

`map2()` is similar to map in almost every way. For example, you can pass extra arguments for your function as additional arguments to `map2()`.

### \t

`map2()` returns its results as a list, but it comes with variants that will return the result in other formats. As with `map()`, you should use the variant of `map2()` that will return your results in the format you want:

Map function | Map2 function | Output
------------ | ------------- | ----------------
`map()`      | `map2()`      | list
`map_chr()`  | `map2_chr()`  | character vector
`map_dbl()`  | `map2_dbl()`  | double (numeric) vector
`map_dfc()`  | `map2_dfc()`  | data frame (output column binded)
`map_dfr()`  | `map2_dfr()`  | data frame (output row binded)
`map_int()`  | `map2_int()`  | integer vector
`map_lgl()`  | `map2_lgl()`  | logical vector
`walk()`     | `walk2()`     | returns the input invisibly (used to trigger side effects)

### Map2 expressions

`map2()` also uses the same shortcuts as `map()`. While the "" and integer shortcuts do not make sense for `map2()`, the expressions shortcut does.

To make an expression for `map2()`:

1. Begin the expression with `~`
2. Refer to elements from the first vector as `.x`
3. Refer to elements from the second vectore as `.y`

Only the last step is different from `map()`.

### Try an expression

The code below extracts the year coefficient of each model and computes the change that results from adding gdpPercap. 

```{r}
pluck(coef(usa_mod2), "year") - pluck(coef(usa_mod1), "year")
```

* Turn the code above into an expression and map it over the `model1` and `model2` lists. 
* Return the results as a double vector, then `enframe()` it.
* Use `arrange()` and `desc()` to see which countries had the biggest change.
* Click Submit Answer when you are finished.

```{r map2-exp, exercise = TRUE}
model1 %>% 
  map2(model2, anova)
```

```{r map2-exp-hint-1}
"First, replace anova with your expression."
```

```{r map2-exp-hint-2}
"Second, replace map2() with a variant that will return a double (numeric) vector."
```

```{r map2-exp-hint-3}
"Third, pass the result to enframe()."
```

```{r map2-exp-hint-4}
"Fourth, pass the result to arrange(). arrange() comes in the dplyr package, you can learn how to use it in the Work with Data primer."
```

```{r map2-exp-hint-5}
'Finally, recall that enframe() named the variable that you want to arrange over "value". Here, you want to arrange over descending values of value.'
```

```{r map2-exp-solution}
model1 %>% 
  map2_dbl(model2, ~pluck(coef(.y), "year") - pluck(coef(.x), "year")) %>% 
  enframe() %>% 
  arrange(desc(value))
```

```{r map2-exp-check}
"Bravo! There was a lot to that exercise and you handled purrrfectly."
```

### But wait ...there's more!

You can use `anova()` to compare any number of models. For example, we could compare three different models for a country:

1. A model that predicts life expectancy by year, like those in `model1`.
1. A model that predicts  life expectancy by both year _and GDP per capita_, like those in `model2`.
1. A model that predicts  life expectancy by year and GDP per capita _and population_, like those in `model3`. (I made `model3` for you while you weren't looking)

### \t 

Here's the comparison for the US

```{r}
usa_mod1 <- model1 %>% pluck("United States")
usa_mod2 <- model2 %>% pluck("United States")
usa_mod3 <- model3 %>% pluck("United States")
anova(usa_mod1, usa_mod2, usa_mod3)
```

Each value in the `Pr(>F)` column shows the p-value that results from comparing the model to the model above it.

Now can we do _this_ for every country?

### Mapping over three vectors

Anova can handle three arguments. Can you?

Yes, but not with `map3()` as you might think. `map3()` doesn't exist. Instead purrr offers the `pmap()` function for mapping over three _or more_ vectors.

### pmap()

The syntax of `pmap()` is a little different from the syntax of `map()` and `map2()`. Instead of accepting vectors one at a time as arguments, `pmap()` expects a single argument that contains a _list of vectors_ and then a function to apply to the vectors within that list of vectors.

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("www/images/pmap.png")
```

### \t

Name each vector in your list of vectors with the name of the argument that it should map to. `pmap()` will match names to arguments whenever you provide them, e.g.

```{r}
nums <- list(pi, exp(1), sqrt(2))
digits <- list(2, 3, 4)
pmap(list(digits = digits, x = nums), round)
```

(if you do not provide names, `pmap()` will map vectors to arguments by order).

### Use pmap()

Got that? Let's give it a try.

* Use `pmap()` to iterate over `model1`, `model2`, and `model3`, applying `anova()` as you go. Then click Submit Answer.

_Note: `anova()` does not use argument names, so you will need to supply model1, model2, and model3 in the correct order._

```{r pmap, exercise = TRUE}

```

```{r pmap-hint}
"Be sure to wrap model1, model2, and model3 in a list before/as you pass them to pmap()."
```

```{r pmap-solution}
pmap(list(model1, model2, model3), anova) 
```

```{r pmap-check}
"Excellent. You can use pmap() to map over three, four, or any number of vectors."
```

### similarities between pmap(), map2() and map()

`pmap()` also tries to resemble `map()` and `map2()` wherever possible. 

Specifically, `pmap()` also comes with derivative functions that return outmput in new formats:

Map function | Map2 function | pmap function | Output
------------ | ------------- | ------------- | --------------
`map()`      | `map2()`      | `pmap()`      | list
`map_chr()`  | `map2_chr()`  | `pmap_chr()`  | character vector
`map_dbl()`  | `map2_dbl()`  | `pmap_dbl()`  | double (numeric) vector
`map_dfc()`  | `map2_dfc()`  | `pmap_dfc()`  | data frame (output column binded)
`map_dfr()`  | `map2_dfr()`  | `pmap_dfr()`  | data frame (output row binded)
`map_int()`  | `map2_int()`  | `pmap_int()`  | integer vector
`map_lgl()`  | `map2_lgl()`  | `pmap_lgl()`  | logical vector
`walk()`     | `walk2()`     | `pwalk()`     | returns the input invisibly (used to trigger side effects)

### \t 

`pmap()` also uses expressions that start with a `~`. However, `pmap()` expects you to name the elements within an expression `..1`, `..2`, `..3` and so on instead of `.x` and `.y`. Notice the double dots.

For example, you could return the year coefficients of each model with the code below.

* Click Run Code to see the results.

```{r pmaps, exercise = TRUE}
pmap(
  list(model1, model2, model3),
  ~c(mod1 = pluck(coef(..1), "year"), 
     mod2 = pluck(coef(..2), "year"), 
     mod3 = pluck(coef(..3), "year"))
)
```

### A few final functions

To be a true purrr master, you should know that a couple more mapping functions come with purrr:

1. `map_at()` and `map_if()`, which only map a function to specific elements of a list
1. `lmap()`, which works exclusively with functions that take lists
1. `imap()`, which applies a function to each element of a vector, and its index
1. `invoke_map()`, which takes a list of functions and a list of arguments

You can learn more about each at their help pages or [purrr.tidyverse.org](purrr.tidyverse.org).

### Congratulations

You've finished the More Map tutorial, and you now have a wealth of new information to think about. 

When you are ready, the List Column tutorial will show you how to integrate your purrr skills with your dplyr skills to create an unusually well organized data science workflow.