---
title: "Map Over Multiple Vectors"
tutorial:
  id: "io.shinyapps.tutorials.more-map"
  version: 0.01
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: false
runtime: shiny_prerendered
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(tidyverse)
library(repurrrsive)


gap_dfs <- gap_split %>% map(select, -1, -2)
gap_list <- gap_dfs %>% map(as.list)

us <- gap_list %>% pluck("United States")

list1 <- list(
  numbers = 1:3,
  letters = c("a", "b", "c"),
  logicals = c(TRUE, FALSE)
)

params <- list(
  "norm1" = list("mu" = 0, "sd" = 1),
  "norm2" = list("mu" = 1, "sd" = 1),
  "norm3" = list("mu" = 2, "scale" = 1)
)

model1 <- gap_dfs %>%
  map(~ lm(lifeExp ~ year, data = .x))

model2 <- gap_dfs %>%
  map(~ lm(lifeExp ~ year + gdpPercap, data = .x))

model3 <- gap_dfs %>%
  map(~ lm(lifeExp ~ year + gdpPercap + pop, data = .x))


checker <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  list(message = check_code, correct = TRUE, location = "append")
}
tutorial_options(exercise.timelimit = 60, exercise.checker = checker)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```



## Multiple Vectors

### \t

In the last section, you computed two models for every country:

1. One that predicted life expectancy by year, which I saved as `model1`.
1. One that predicted life expectancy by both year _and GDP per capita_, which I saved as `model2`.

Does adding GDP per capita improve your predictions for life expectancy?

### anova() 

One way to tell is with the `anova()` function. `anova()` takes two models and tests whether the second model outperforms the first.

Let's try it. We can use our two models for the United States

```{r}
usa_mod1 <- model1 %>% pluck("United States")
usa_mod2 <- model2 %>% pluck("United States")
```

### \t

The anova results suggest that adding GDP per capita did _not_ improve your predictions for the US. 

How can you tell? The very last number in the table is a p-value (here 0.1424). If the number is above 0.05, there's not enough evidence to suggest that the second model outperforms the first: you can ascribe the difference between the two to random chance.

```{r}
anova(usa_mod1, usa_mod2)
```

### Beyond the US

So GDP per capita doesn't improve your predictions for the United States, but what about for the other countries? 

You can iterate through all of the countries to find out, but this is a new type of iteration problem. At each step, `anova()` will require one element from `model1` and one element from `model2`. You'll need to simultaneously iterate over _two_ lists.

### map2()

Enter `map2()`.

Syntactically, `map2()` behaves like `map()`, but it takes _two_ vectors as arguments before it takes a function (remember that lists are a type of vector). 

At each step of the iteration, `map2()` will pass an element from the first vector to the first argument of the function. It will pass an element from the second vector to the second argument of the function.

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("www/images/map2.png")
```

### \t

* Use `map2()` to run an anova on each pair of models in `model1` and `model2`. Then click Submit Answer.

```{r map2, exercise = TRUE}

```

```{r map2-solution}
map2(list1, list2, anova)
```

```{r map2-check}
"Nice job! A quick scan of the results suggests that adding gdpPercap only improved your predictions for the poorest countries."
```

### map2() and map()

`map2()` is similar to map in almost every way. For example, you can pass extra arguments for your function as additional arguments to `map2()`.

### \t

`map2()` returns its results as a list, but it comes with variants that will return the result in other formats. As with `map()`, you should use the variant of `map2()` that will return your results in the format you want:

Map function | Map2 function | Output
------------ | ------------- | ----------------
`map()`      | `map2()`      | list
`map_chr()`  | `map2_chr()`  | character vector
`map_dbl()`  | `map2_dbl()`  | double (numeric) vector
`map_dfc()`  | `map2_dfc()`  | data frame (output column binded)
`map_dfr()`  | `map2_dfr()`  | data frame (output row binded)
`map_int()`  | `map2_int()`  | integer vector
`map_lgl()`  | `map2_lgl()`  | logical vector
`walk()`     | `walk2()`     | returns the input invisibly (used to trigger side effects)

### Map2 expressions

`map2()` also uses the same shortcuts as `map()`. While the "" and integer shortcuts do not make sense for `map2()`, the expressions shortcut does.

To make an expression for `map2()`:

1. Begin the expression with `~`
2. Refer to elements from the first vector as `.x`
3. Refer to elements from the second vectore as `.y`

Only the last step is different from `map()`.

### Try an expression

The code below extracts the year coefficient of each model and computes the change that results from adding gdpPercap. 

```{r}
pluck(coef(usa_mod2), "year") - pluck(coef(usa_mod1), "year")
```

* Turn the code above into an expression and map it over the `model1` and `model2` lists. 
* Return the results as a double vector, then `enframe()` it.
* Use `arrange()` and `desc()` to see which countries had the biggest change.
* Click Submit Answer when you are finished.

```{r map2-exp, exercise = TRUE}
model1 %>%
  map2(model2, anova)
```

```{r map2-exp-hint-1}
"First, replace anova with your expression."
```

```{r map2-exp-hint-2}
"Second, replace map2() with a variant that will return a double (numeric) vector."
```

```{r map2-exp-hint-3}
"Third, pass the result to enframe()."
```

```{r map2-exp-hint-4}
"Fourth, pass the result to arrange(). arrange() comes in the dplyr package, you can learn how to use it in the Work with Data primer."
```

```{r map2-exp-hint-5}
'Finally, recall that enframe() named the variable that you want to arrange over "value". Here, you want to arrange over descending values of value.'
```

```{r map2-exp-solution}
model1 %>%
  map2_dbl(model2, ~ pluck(coef(.y), "year") - pluck(coef(.x), "year")) %>%
  enframe() %>%
  arrange(desc(value))
```

```{r map2-exp-check}
"Bravo! There was a lot to that exercise and you handled purrrfectly."
```

### But wait ...there's more!

You can use `anova()` to compare any number of models. For example, we could compare three different models for a country:

1. A model that predicts life expectancy by year, like those in `model1`.
1. A model that predicts  life expectancy by both year _and GDP per capita_, like those in `model2`.
1. A model that predicts  life expectancy by year and GDP per capita _and population_, like those in `model3`. (I made `model3` for you while you weren't looking)

### \t 

Here's the comparison for the US

```{r}
usa_mod1 <- model1 %>% pluck("United States")
usa_mod2 <- model2 %>% pluck("United States")
usa_mod3 <- model3 %>% pluck("United States")
anova(usa_mod1, usa_mod2, usa_mod3)
```

Each value in the `Pr(>F)` column shows the p-value that results from comparing the model to the model above it.

Now can we do _this_ for every country?

### Mapping over three vectors

Anova can handle three arguments. Can you?

Yes, but not with `map3()` as you might think. `map3()` doesn't exist. Instead purrr offers the `pmap()` function for mapping over three _or more_ vectors.

### pmap()

The syntax of `pmap()` is a little different from the syntax of `map()` and `map2()`. Instead of accepting vectors one at a time as arguments, `pmap()` expects a single argument that contains a _list of vectors_ and then a function to apply to the vectors within that list of vectors.

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("www/images/pmap.png")
```

### \t

Name each vector in your list of vectors with the name of the argument that it should map to. `pmap()` will match names to arguments whenever you provide them, e.g.

```{r}
nums <- list(pi, exp(1), sqrt(2))
digits <- list(2, 3, 4)
pmap(list(digits = digits, x = nums), round)
```

(if you do not provide names, `pmap()` will map vectors to arguments by order).

### Use pmap()

Got that? Let's give it a try.

* Use `pmap()` to iterate over `model1`, `model2`, and `model3`, applying `anova()` as you go. Then click Submit Answer.

_Note: `anova()` does not use argument names, so you will need to supply model1, model2, and model3 in the correct order._

```{r pmap, exercise = TRUE}

```

```{r pmap-hint}
"Be sure to wrap model1, model2, and model3 in a list before/as you pass them to pmap()."
```

```{r pmap-solution}
pmap(list(model1, model2, model3), anova)
```

```{r pmap-check}
"Excellent. You can use pmap() to map over three, four, or any number of vectors."
```

### similarities between pmap(), map2() and map()

`pmap()` also tries to resemble `map()` and `map2()` wherever possible. 

Specifically, `pmap()` also comes with derivative functions that return outmput in new formats:

Map function | Map2 function | pmap function | Output
------------ | ------------- | ------------- | --------------
`map()`      | `map2()`      | `pmap()`      | list
`map_chr()`  | `map2_chr()`  | `pmap_chr()`  | character vector
`map_dbl()`  | `map2_dbl()`  | `pmap_dbl()`  | double (numeric) vector
`map_dfc()`  | `map2_dfc()`  | `pmap_dfc()`  | data frame (output column binded)
`map_dfr()`  | `map2_dfr()`  | `pmap_dfr()`  | data frame (output row binded)
`map_int()`  | `map2_int()`  | `pmap_int()`  | integer vector
`map_lgl()`  | `map2_lgl()`  | `pmap_lgl()`  | logical vector
`walk()`     | `walk2()`     | `pwalk()`     | returns the input invisibly (used to trigger side effects)

### \t 

`pmap()` also uses expressions that start with a `~`. However, `pmap()` expects you to name the elements within an expression `..1`, `..2`, `..3` and so on instead of `.x` and `.y`. Notice the double dots.

For example, you could return the year coefficients of each model with the code below.

* Click Run Code to see the results.

```{r pmaps, exercise = TRUE}
pmap(
  list(model1, model2, model3),
  ~ c(
    mod1 = pluck(coef(..1), "year"),
    mod2 = pluck(coef(..2), "year"),
    mod3 = pluck(coef(..3), "year")
  )
)
```

### A few final functions

To be a true purrr master, you should know that a couple more mapping functions come with purrr:

1. `map_at()` and `map_if()`, which only map a function to specific elements of a list
1. `lmap()`, which works exclusively with functions that take lists
1. `imap()`, which applies a function to each element of a vector, and its index
1. `invoke_map()`, which takes a list of functions and a list of arguments

You can learn more about each at their help pages or [purrr.tidyverse.org](purrr.tidyverse.org).

### Congratulations

You've finished the More Map tutorial, and you now have a wealth of new information to think about. 

When you are ready, the List Column tutorial will show you how to integrate your purrr skills with your dplyr skills to create an unusually well organized data science workflow.




